{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typedload Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. It is released with a GPLv3 license. Example For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data) Supported types Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any Using Mypy # This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format. Install pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases Documentation Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module. Used by As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Home"},{"location":"#typedload","text":"Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. It is released with a GPLv3 license.","title":"typedload"},{"location":"#example","text":"For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data)","title":"Example"},{"location":"#supported-types","text":"Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any","title":"Supported types"},{"location":"#using-mypy","text":"# This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format.","title":"Using Mypy"},{"location":"#install","text":"pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases","title":"Install"},{"location":"#documentation","text":"Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module.","title":"Documentation"},{"location":"#used-by","text":"As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Used by"},{"location":"CHANGELOG/","text":"2.12 Add uniondebugconflict flag to detect unions with conflicts. 2.11 Make newer mypy happy 2.10 Fix setup.py referring to a non-existing file when installing with pip 2.9 Use README on pypi.org Tiny speed improvement Expanded and improved documentation 2.8 Better report errors for Enum Improve support for inheritance with mixed totality of TypedDict (requires Python 3.9) 2.7 failonextra triggers failure when dropping fields in mangling Support for total=False in TypedDict Support init=False in dataclass field 2.6 Handle Any types as passthrough Easy way to handle types loaded from and dumped to str Improve how exceptions are displayed 2.5 Fix dump for attr classes with factory Let name mangling use arbitrary metadata fields rather than just name 2.4 Support for ipaddress.IPv4Address , ipaddress.IPv6Address , ipaddress.IPv4Network , ipaddress.IPv6Network , ipaddress.IPv4Interface , ipaddress.IPv6Interface . 2.3 Better type sorting in Union This helps when using Union[dataclass, str] 2.2 Add Python3.9 to the supported versions Prevent loading dict as List , Tuple , Set This helps when using Union[Dict, List] to take the correct type. 2.1 Written new usage example typechecks internals now pass with more mypy configurations Fix import * 2.0 Breaking API change: handlers can only be modified before the first load Breaking API change: plugins removed (attr support is by default) Exceptions contain more information Greatly improve performances with iterables types Support for pathlib.Path 1.20 Drop support for Python 3.5.2 (3.5 series is still supported) Support TypedDict More precise type annotation of TypedloadException and Annotation fields Deprecate the plugin to handle attr.s and make it always supported. This means that there will be no need for special code. Fix datetime loader raising exceptions with the wrong type 1.19 Add support for Literal . 1.18 Improved documentation Debian builds are now done source only 1.17 Prefer the same type in union loading 1.16 New uniontypes() function. Make list and dictionary loaders raise the correct exceptions Able to load from argparse.Namespace 1.15 Add support for FrozenSet[T] . Define __all__ for typechecks. Add name mangling support in dataclass, to match attrs. Add support for datetime.date , datetime.time , datetime.datetime 1.14 Add support for Tuple[t, ...] 1.13 Fix bug in loading attr classes and passing random crap. Now the proper exception is raised. New module to expose the internal type checks functions 1.12 Support fields with factory for dataclass 1.11 Fixed problem when printing sub-exceptions of failed unions Improve documentation 1.10 Make mypy happy again 1.9 Support ForwardRef Add a new Exception type with more details on the error (no breaking API changes) 1.8 Make mypy happy again 1.7 Make mypy happy again 1.6 Run tests on older python as well Support for dataclass (Since python 3.7) Added methods to find the appropriate handlers 1.5 Improve handling of unions Better continuous integration Support python 3.7 1.4 Add support for name mangling in attr plugin Parameters can be passed as kwargs Improved exception message for NamedTuple loading 1.3 Add support for Python < 3.5.3 1.2 Ship the plugins in pypy 1.1 Able to load and dump old style NamedTuple Support for Python 3.5 Target to run mypy in makefile Refactor to support plugins. The API is still compatible. Plugin for the attr module, seems useful in Python 3.5 1.0 Has a setting to hide default fields or not, in dumps Better error reporting Add file for PEP 561 0.9 Initial release","title":"Changelog"},{"location":"CHANGELOG/#212","text":"Add uniondebugconflict flag to detect unions with conflicts.","title":"2.12"},{"location":"CHANGELOG/#211","text":"Make newer mypy happy","title":"2.11"},{"location":"CHANGELOG/#210","text":"Fix setup.py referring to a non-existing file when installing with pip","title":"2.10"},{"location":"CHANGELOG/#29","text":"Use README on pypi.org Tiny speed improvement Expanded and improved documentation","title":"2.9"},{"location":"CHANGELOG/#28","text":"Better report errors for Enum Improve support for inheritance with mixed totality of TypedDict (requires Python 3.9)","title":"2.8"},{"location":"CHANGELOG/#27","text":"failonextra triggers failure when dropping fields in mangling Support for total=False in TypedDict Support init=False in dataclass field","title":"2.7"},{"location":"CHANGELOG/#26","text":"Handle Any types as passthrough Easy way to handle types loaded from and dumped to str Improve how exceptions are displayed","title":"2.6"},{"location":"CHANGELOG/#25","text":"Fix dump for attr classes with factory Let name mangling use arbitrary metadata fields rather than just name","title":"2.5"},{"location":"CHANGELOG/#24","text":"Support for ipaddress.IPv4Address , ipaddress.IPv6Address , ipaddress.IPv4Network , ipaddress.IPv6Network , ipaddress.IPv4Interface , ipaddress.IPv6Interface .","title":"2.4"},{"location":"CHANGELOG/#23","text":"Better type sorting in Union This helps when using Union[dataclass, str]","title":"2.3"},{"location":"CHANGELOG/#22","text":"Add Python3.9 to the supported versions Prevent loading dict as List , Tuple , Set This helps when using Union[Dict, List] to take the correct type.","title":"2.2"},{"location":"CHANGELOG/#21","text":"Written new usage example typechecks internals now pass with more mypy configurations Fix import *","title":"2.1"},{"location":"CHANGELOG/#20","text":"Breaking API change: handlers can only be modified before the first load Breaking API change: plugins removed (attr support is by default) Exceptions contain more information Greatly improve performances with iterables types Support for pathlib.Path","title":"2.0"},{"location":"CHANGELOG/#120","text":"Drop support for Python 3.5.2 (3.5 series is still supported) Support TypedDict More precise type annotation of TypedloadException and Annotation fields Deprecate the plugin to handle attr.s and make it always supported. This means that there will be no need for special code. Fix datetime loader raising exceptions with the wrong type","title":"1.20"},{"location":"CHANGELOG/#119","text":"Add support for Literal .","title":"1.19"},{"location":"CHANGELOG/#118","text":"Improved documentation Debian builds are now done source only","title":"1.18"},{"location":"CHANGELOG/#117","text":"Prefer the same type in union loading","title":"1.17"},{"location":"CHANGELOG/#116","text":"New uniontypes() function. Make list and dictionary loaders raise the correct exceptions Able to load from argparse.Namespace","title":"1.16"},{"location":"CHANGELOG/#115","text":"Add support for FrozenSet[T] . Define __all__ for typechecks. Add name mangling support in dataclass, to match attrs. Add support for datetime.date , datetime.time , datetime.datetime","title":"1.15"},{"location":"CHANGELOG/#114","text":"Add support for Tuple[t, ...]","title":"1.14"},{"location":"CHANGELOG/#113","text":"Fix bug in loading attr classes and passing random crap. Now the proper exception is raised. New module to expose the internal type checks functions","title":"1.13"},{"location":"CHANGELOG/#112","text":"Support fields with factory for dataclass","title":"1.12"},{"location":"CHANGELOG/#111","text":"Fixed problem when printing sub-exceptions of failed unions Improve documentation","title":"1.11"},{"location":"CHANGELOG/#110","text":"Make mypy happy again","title":"1.10"},{"location":"CHANGELOG/#19","text":"Support ForwardRef Add a new Exception type with more details on the error (no breaking API changes)","title":"1.9"},{"location":"CHANGELOG/#18","text":"Make mypy happy again","title":"1.8"},{"location":"CHANGELOG/#17","text":"Make mypy happy again","title":"1.7"},{"location":"CHANGELOG/#16","text":"Run tests on older python as well Support for dataclass (Since python 3.7) Added methods to find the appropriate handlers","title":"1.6"},{"location":"CHANGELOG/#15","text":"Improve handling of unions Better continuous integration Support python 3.7","title":"1.5"},{"location":"CHANGELOG/#14","text":"Add support for name mangling in attr plugin Parameters can be passed as kwargs Improved exception message for NamedTuple loading","title":"1.4"},{"location":"CHANGELOG/#13","text":"Add support for Python < 3.5.3","title":"1.3"},{"location":"CHANGELOG/#12","text":"Ship the plugins in pypy","title":"1.2"},{"location":"CHANGELOG/#11","text":"Able to load and dump old style NamedTuple Support for Python 3.5 Target to run mypy in makefile Refactor to support plugins. The API is still compatible. Plugin for the attr module, seems useful in Python 3.5","title":"1.1"},{"location":"CHANGELOG/#10","text":"Has a setting to hide default fields or not, in dumps Better error reporting Add file for PEP 561","title":"1.0"},{"location":"CHANGELOG/#09","text":"Initial release","title":"0.9"},{"location":"CODE_OF_CONDUCT/","text":"International code of conduct No USA cultural imperialism allowed This project welcomes every contributor from any background. For this reason we can't let the USA and USA influenced politically correct culture dictate conduct for everyone. Diversity is beautiful, let's not ask of people to forgo their culture to contribute. Achieving social justice is important. Being superficial about it only to feel morally superior is not the way to achieve it and is not tolerated here. The code of conduct only pertains this project This document only applies to the project and the communication channels. It does not apply to anything any contributor might say or do outside of project channels. It only applies to contributors. People whose only contribution is a code of conduct complaint are not contributors. Language Try to be nice and constructive. Harassing and intentionally offending other people is not allowed. Foul language is allowed. People often contribute to this project in their own time and are not paid, for this reason asking contributors to behave \"professionally\" makes no sense. Hobbies do not require professionality. Jokes are allowed. It can happen to unintentionally offend someone. Do not reiterate the offensive behaviour, provided that the request is reasonable. People who are easily offended by things not intended to be offensive must try to become more tolerant towards other people, other cultures and their ways of expressing themselves. For example, a person might consider offensive the sight of a woman with or without a headscarf. This person needs to try to become more tolerant to other people's culture. It is not allowed to be offended on behalf of others. Please do not presume to know what others are thinking. Examples of allowed language: This software is retarded This program runs like shit This bug is annoying Examples of disallowed language: You are retarded You are shitty and so is your program Skill discrimination is absolutely fine Unlike other code of conducts, this allows skill discrimination. Everyone is welcome to contribute according to their skill level and more experienced contributors are encouraged to act as mentors. It is nice if they have time and patience to mentor potential contributors, but since time is a limited resource, it is also fine to turn down low quality and low effort contributions with little explaination. New contributors are expected to respond to comments and be willing to improve the quality of their contribution. Conflict resolution This code of conduct is inevitably vague. Follow the intention rather than the letter. The final word rests with the project owners or their delegates. Changes to license It is not allowed to ask for license change and complain about copyleft. If you disagree with the license, feel free to start your own project from scratch without getting in touch and never look at the source code, to avoid copyright issues. See also International code of conduct","title":"Code of conduct"},{"location":"CODE_OF_CONDUCT/#international-code-of-conduct","text":"","title":"International code of conduct"},{"location":"CODE_OF_CONDUCT/#no-usa-cultural-imperialism-allowed","text":"This project welcomes every contributor from any background. For this reason we can't let the USA and USA influenced politically correct culture dictate conduct for everyone. Diversity is beautiful, let's not ask of people to forgo their culture to contribute. Achieving social justice is important. Being superficial about it only to feel morally superior is not the way to achieve it and is not tolerated here.","title":"No USA cultural imperialism allowed"},{"location":"CODE_OF_CONDUCT/#the-code-of-conduct-only-pertains-this-project","text":"This document only applies to the project and the communication channels. It does not apply to anything any contributor might say or do outside of project channels. It only applies to contributors. People whose only contribution is a code of conduct complaint are not contributors.","title":"The code of conduct only pertains this project"},{"location":"CODE_OF_CONDUCT/#language","text":"Try to be nice and constructive. Harassing and intentionally offending other people is not allowed. Foul language is allowed. People often contribute to this project in their own time and are not paid, for this reason asking contributors to behave \"professionally\" makes no sense. Hobbies do not require professionality. Jokes are allowed. It can happen to unintentionally offend someone. Do not reiterate the offensive behaviour, provided that the request is reasonable. People who are easily offended by things not intended to be offensive must try to become more tolerant towards other people, other cultures and their ways of expressing themselves. For example, a person might consider offensive the sight of a woman with or without a headscarf. This person needs to try to become more tolerant to other people's culture. It is not allowed to be offended on behalf of others. Please do not presume to know what others are thinking. Examples of allowed language: This software is retarded This program runs like shit This bug is annoying Examples of disallowed language: You are retarded You are shitty and so is your program","title":"Language"},{"location":"CODE_OF_CONDUCT/#skill-discrimination-is-absolutely-fine","text":"Unlike other code of conducts, this allows skill discrimination. Everyone is welcome to contribute according to their skill level and more experienced contributors are encouraged to act as mentors. It is nice if they have time and patience to mentor potential contributors, but since time is a limited resource, it is also fine to turn down low quality and low effort contributions with little explaination. New contributors are expected to respond to comments and be willing to improve the quality of their contribution.","title":"Skill discrimination is absolutely fine"},{"location":"CODE_OF_CONDUCT/#conflict-resolution","text":"This code of conduct is inevitably vague. Follow the intention rather than the letter. The final word rests with the project owners or their delegates.","title":"Conflict resolution"},{"location":"CODE_OF_CONDUCT/#changes-to-license","text":"It is not allowed to ask for license change and complain about copyleft. If you disagree with the license, feel free to start your own project from scratch without getting in touch and never look at the source code, to avoid copyright issues.","title":"Changes to license"},{"location":"CODE_OF_CONDUCT/#see-also","text":"International code of conduct","title":"See also"},{"location":"CONTRIBUTING/","text":"Contributing All contributions must pass the test suite and must generate no warnings with the latest available version of mypy. The best way of sending changes is to use git-send-mail to tiposchi@tiscali.it It is acceptable also to use github's pull request functionality. Contributors must accept that their changes can use both GPL3 and LGPL3. Currently the license is GPL3 with one exception being made for the company where I work. In the future more LGPL3 exception could be made, but no other license than those will be used.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All contributions must pass the test suite and must generate no warnings with the latest available version of mypy. The best way of sending changes is to use git-send-mail to tiposchi@tiscali.it It is acceptable also to use github's pull request functionality. Contributors must accept that their changes can use both GPL3 and LGPL3. Currently the license is GPL3 with one exception being made for the company where I work. In the future more LGPL3 exception could be made, but no other license than those will be used.","title":"Contributing"},{"location":"SECURITY/","text":"Security Policy I do not expect any security issues in this package, but just to make github happy. Supported Versions Only the latest release is supported. I will not backport fixes. Reporting a Vulnerability Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Security Policy"},{"location":"SECURITY/#security-policy","text":"I do not expect any security issues in this package, but just to make github happy.","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"Only the latest release is supported. I will not backport fixes.","title":"Supported Versions"},{"location":"SECURITY/#reporting-a-vulnerability","text":"Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Reporting a Vulnerability"},{"location":"comparisons/","text":"Comparisons In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: Works with existing codebase and uses standard types. No inheritance or decorators Easy to extend, even with objects from 3rd party libraries Supports Union Works on python 3.5 Mypy and similar work without plugins Can use camelCase and snake_case Functional approach It works with existing codebase Most libraries require your classes to extend or use decorators from the library itself. This means that types from other libraries or non supported stdlib classes can never be used. It also means that mypy will just work out of the box, rather than requiring plugins. Instead, typedload works fine with the type annotations from the typing module and will work without requiring any changes to the datatypes. It also works on python 3.5, so projects running on LTS distributions can use it. It is easy to extend Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases. Support of Union Seems to be very rare in this domain, but unions are very common in real world datasets. Functional approach You can load a List[YourType] , while pydantic can only load a single object that then will contain the list. pydantic Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Union might do casting when casting is not needed. dataclasses-json Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"Comparisons"},{"location":"comparisons/#comparisons","text":"In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: Works with existing codebase and uses standard types. No inheritance or decorators Easy to extend, even with objects from 3rd party libraries Supports Union Works on python 3.5 Mypy and similar work without plugins Can use camelCase and snake_case Functional approach","title":"Comparisons"},{"location":"comparisons/#it-works-with-existing-codebase","text":"Most libraries require your classes to extend or use decorators from the library itself. This means that types from other libraries or non supported stdlib classes can never be used. It also means that mypy will just work out of the box, rather than requiring plugins. Instead, typedload works fine with the type annotations from the typing module and will work without requiring any changes to the datatypes. It also works on python 3.5, so projects running on LTS distributions can use it.","title":"It works with existing codebase"},{"location":"comparisons/#it-is-easy-to-extend","text":"Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases.","title":"It is easy to extend"},{"location":"comparisons/#support-of-union","text":"Seems to be very rare in this domain, but unions are very common in real world datasets.","title":"Support of Union"},{"location":"comparisons/#functional-approach","text":"You can load a List[YourType] , while pydantic can only load a single object that then will contain the list.","title":"Functional approach"},{"location":"comparisons/#pydantic","text":"Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Union might do casting when casting is not needed.","title":"pydantic"},{"location":"comparisons/#dataclasses-json","text":"Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"dataclasses-json"},{"location":"errors/","text":"Errors in typedload All exceptions are subclasses of TypedloadException . To make sure of that, there is an assertion in place that will fail if a type handler is misbehaving and raising the wrong type of exception. The exceptions have a clear user message, but they offer an API to expose precise knowledge of the problem. String trace By default when an error occurrs the path within the data structure is shown. from typing import * import typedload class Thing(NamedTuple): value: int class Data(NamedTuple): field1: List[Thing] field2: Tuple[Thing, ...] typedload.load({'field1': [{'value': 12}, {'value': 'a'}], 'field2': []}, Data) TypedloadValueError: invalid literal for int() with base 10: 'a' Path: .field1.[1].value The path in the string description tells where the wrong value was found. Trace To be able to locate where in the data an exception happened, TypedloadException has the trace property, which contains a list TraceItem , which help to track where the exception happened. This can be useful to do more clever error handling. For example: try: typedload.load([1, 2, 'a'], List[int]) except Exception as e: print(e.trace[-1]) Will raise an exception and print the last element in the trace TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) Another example, with an object: class O(NamedTuple): data: List[int] try: typedload.load({'data': [1, 2, 'a']}, O) except Exception as e: for i in e.trace: print(i) Will print the entire trace: TraceItem(value={'data': [1, 2, 'a']}, type_=<class '__main__.O'>, annotation=None) TraceItem(value=[1, 2, 'a'], type_=typing.List[int], annotation=Annotation(annotation_type=<AnnotationType.FIELD: 'field'>, value='data')) TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) And checking the annotation field it is possible to find out that the issue happened in data at index 2 . Union Because it is normal for a union of n types to generate n-1 exceptions, a union which fails generated n exceptions. Typedload has no way of knowing which of those is the important exception that was expected to succeed and instead puts all the exceptions inside the exception field of the parent exception. So all the sub exceptions can be investigated to decide which one is the most relevant one. Raise exceptions in custom handlers To find the path where the wrong value was found, typedload needs to trace the execution by using annotations. This is used in handlers that do recursive calls to the loader. See the source code of the handlers for Union and NamedTuple to see how this is done.","title":"Errors"},{"location":"errors/#errors-in-typedload","text":"All exceptions are subclasses of TypedloadException . To make sure of that, there is an assertion in place that will fail if a type handler is misbehaving and raising the wrong type of exception. The exceptions have a clear user message, but they offer an API to expose precise knowledge of the problem.","title":"Errors in typedload"},{"location":"errors/#string-trace","text":"By default when an error occurrs the path within the data structure is shown. from typing import * import typedload class Thing(NamedTuple): value: int class Data(NamedTuple): field1: List[Thing] field2: Tuple[Thing, ...] typedload.load({'field1': [{'value': 12}, {'value': 'a'}], 'field2': []}, Data) TypedloadValueError: invalid literal for int() with base 10: 'a' Path: .field1.[1].value The path in the string description tells where the wrong value was found.","title":"String trace"},{"location":"errors/#trace","text":"To be able to locate where in the data an exception happened, TypedloadException has the trace property, which contains a list TraceItem , which help to track where the exception happened. This can be useful to do more clever error handling. For example: try: typedload.load([1, 2, 'a'], List[int]) except Exception as e: print(e.trace[-1]) Will raise an exception and print the last element in the trace TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) Another example, with an object: class O(NamedTuple): data: List[int] try: typedload.load({'data': [1, 2, 'a']}, O) except Exception as e: for i in e.trace: print(i) Will print the entire trace: TraceItem(value={'data': [1, 2, 'a']}, type_=<class '__main__.O'>, annotation=None) TraceItem(value=[1, 2, 'a'], type_=typing.List[int], annotation=Annotation(annotation_type=<AnnotationType.FIELD: 'field'>, value='data')) TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) And checking the annotation field it is possible to find out that the issue happened in data at index 2 .","title":"Trace"},{"location":"errors/#union","text":"Because it is normal for a union of n types to generate n-1 exceptions, a union which fails generated n exceptions. Typedload has no way of knowing which of those is the important exception that was expected to succeed and instead puts all the exceptions inside the exception field of the parent exception. So all the sub exceptions can be investigated to decide which one is the most relevant one.","title":"Union"},{"location":"errors/#raise-exceptions-in-custom-handlers","text":"To find the path where the wrong value was found, typedload needs to trace the execution by using annotations. This is used in handlers that do recursive calls to the loader. See the source code of the handlers for Union and NamedTuple to see how this is done.","title":"Raise exceptions in custom handlers"},{"location":"examples/","text":"Examples Objects Three different kinds of objects are supported to be loaded and dumped back. NamedTuple (stdlib) dataclass (stdlib, since 3.7) attrs (3rd party module) More or less they all work in the same way: the object is defined, types are assigned for the fields and typedload can inspect the class and create an instance from a dictionary, or go the other way to a dictionary from an instance. from typing import NamedTuple, List from pathlib import Path import typedload from attr import attrs, attrib class File(NamedTuple): path: Union[str, Path] size: int @attrs class Directory: name = str files: List[File] = attrib(factory=list) # mutable objects require a factory, not a default value dir = { 'name': 'home', 'files': [ {'path': '/asd.txt', 'size': 0}, {'path': '/tmp/test.txt', 'size': 30}, ] } # Load the dictionary into objects d = typedload.load(dir, Directory) # Out: Directory(files=[File(path='/asd.txt', size=0), File(path='/tmp/test.txt', size=30)]) # Dump the objects into a dictionary typedload.dump(d) Please see the other sections for more advanced usage. Optional values Python typing is a bit confusing about Optional . An Optional[T] means that the field can assume None as value, but the value must still be specified, and can't be omitted. If, on the other hand, a variable has a default value, then when it's not explicitly specified, the default value is assumed. Typedload follows exactly the normal behaviour of python and mypy. import typedload from typing import Optional, NamedTuple class User(NamedTuple): username: str # Must be assigned nickname: Optional[str] # Must be assigned and can be None last_login: Optional[int] = None # Not required. # This fails, as nickname is not present typedload.load({'username': 'ltworf'}, User) # TypedloadValueError: Value does not contain fields: {'nickname'} which are necessary for type User # Those 2 work fine typedload.load({'username': 'ltworf', 'nickname': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': 'LtWorf'}, User) # Out: User(username='ltworf', nickname='LtWorf', last_login=None) # Those 2 work fine too typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': 666}, User) # Out: User(username='ltworf', nickname=None, last_login=666) There is of course no relationship between a default value and Optional , so a default can be anything. class Coordinates(NamedTuple): x: int = 0 y: int = 0 When dumping values, the fields which match with their default value are omitted. # Returns an empty dictionary typedload.dump(Coordinates()) # Out: {} # Returns only the x value typedload.dump(Coordinates(x=42, y=0)) # Out: {'x': 42} # Returns both coordinates typedload.dump(Coordinates(), hidedefault=False) # Out: {'x': 0, 'y': 0} Unions Disable cast Many times it is beneficial to disable casting when loading. For example, if a value can be an object of a certain kind or a string, not disabling casting will cast any invalid object to a string, which might not be desired. import typedload from typing import NamedTuple, Union class Data(NamedTuple): data: int # This loads \"{'date': 33}\", since the object is not a valid Data object. typedload.load({'date': 33}, Union[str, Data]) # Out: \"{'date': 33}\" # This fails, because the dictionary is not cast to str typedload.load({'date': 33}, Union[str, Data], basiccast=False) # TypedloadValueError: Value of dict could not be loaded into typing.Union[str, __main__.Data] List or single object Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_points # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points # Out: [Point(x=1.4, y=4.1), Point(x=5.2, y=6.13)] typedload.load(data1, Data).data_points # Out: [Point(x=1.4, y=4.1)] typedload.load(data2, Data).data_points # Out: [] Objects Loading different objects with a Union is of course possible, but some care is needed to avoid unexpected results. For example, using objects with default values is a bad idea: import typedload from typing import NamedTuple, Union, Optional class Person(NamedTuple): name: str = '' class Data(NamedTuple): data: Optional[str] = None # WARNING: This might return either a Person or a Data. It's random typedload.load({}, Union[Person, Data]) # Out: Data(data=None) # Out: Person(name='') This happens because in the union the order of the type is random, and either object works fine. So you want to use union on objects that have at least one non default non colliding field. You might want to use failonextra for objects whose fields are subset of other objects. import typedload from typing import NamedTuple, Union class Person(NamedTuple): name: str class Car(NamedTuple): name: str model: str # This should be a Car, not a Person data = {'name': 'macchina', 'model': 'TP21'} # WARNING: This can return either a Person or a Car typedload.load(data, Union[Person, Car]) # Out: Person(name='macchina') # Out: Car(name='macchina', model='TP21') # This can be explained by checking that both of these work typedload.load(data, Person) # Out: Person(name='macchina') typedload.load(data, Car) # Out: Car(name='macchina', model='TP21') # The data we have works for both objects, and the union # picks the first one (python sorts them randomly) # We want to avoid that dictionary to be loaded as Person, so we use failonextra # This fails typedload.load(data, Person, failonextra=True) # TypedloadValueError: Dictionary has unrecognized fields: model and cannot be loaded into Person # This works typedload.load(data, Car, failonextra=True) # Out: Car(name='macchina', model='TP21') # At this point the union will reliably pick the class that we want typedload.load(data, Union[Person, Car], failonextra=True) # Out: Car(name='macchina', model='TP21') Object type in value Let's assume that our json objects contain a type field that names the object itself. This makes conflicts impossible and so in the union the correct type will always be picked. Slack sends events in this way. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) # Out: [Message(type='message', text='hello'), UserJoined(type='user-joined', username='giuf\u00e0')] Name mangling Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') When dumping back the data typedload.dump(character) # Out: {'lastName': 'Paperino', 'firstName': 'Paolino'} the names will be converted back to camel case. Multiple name mangling schemes If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') typedload.dump(character, mangle_key='alt_name') # Out: {'last-name': 'Paperino', 'first-name': 'Paolino'} Load and dump types from str Some classes are easy to load and dump from str . For example this is done for Path . Let's assume we want to have a class that is called SerialNumber that we load from a string and dump back to a string. Here's how it can be done: from typing import List import typedload.datadumper import typedload.dataloader class SerialNumber: def __init__(self, sn: str) -> None: # Some validation if ' ' in sn: raise Exception('Invalid serial number') self.sn = sn def __str__(self): return self.sn l = typedload.dataloader.Loader() d = typedload.datadumper.Dumper() l.strconstructed.add(SerialNumber) d.strconstructed.add(SerialNumber) serials = l.load(['1', '2', '3'], List[SerialNumber]) d.dump(serials) Custom handlers Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#objects","text":"Three different kinds of objects are supported to be loaded and dumped back. NamedTuple (stdlib) dataclass (stdlib, since 3.7) attrs (3rd party module) More or less they all work in the same way: the object is defined, types are assigned for the fields and typedload can inspect the class and create an instance from a dictionary, or go the other way to a dictionary from an instance. from typing import NamedTuple, List from pathlib import Path import typedload from attr import attrs, attrib class File(NamedTuple): path: Union[str, Path] size: int @attrs class Directory: name = str files: List[File] = attrib(factory=list) # mutable objects require a factory, not a default value dir = { 'name': 'home', 'files': [ {'path': '/asd.txt', 'size': 0}, {'path': '/tmp/test.txt', 'size': 30}, ] } # Load the dictionary into objects d = typedload.load(dir, Directory) # Out: Directory(files=[File(path='/asd.txt', size=0), File(path='/tmp/test.txt', size=30)]) # Dump the objects into a dictionary typedload.dump(d) Please see the other sections for more advanced usage.","title":"Objects"},{"location":"examples/#optional-values","text":"Python typing is a bit confusing about Optional . An Optional[T] means that the field can assume None as value, but the value must still be specified, and can't be omitted. If, on the other hand, a variable has a default value, then when it's not explicitly specified, the default value is assumed. Typedload follows exactly the normal behaviour of python and mypy. import typedload from typing import Optional, NamedTuple class User(NamedTuple): username: str # Must be assigned nickname: Optional[str] # Must be assigned and can be None last_login: Optional[int] = None # Not required. # This fails, as nickname is not present typedload.load({'username': 'ltworf'}, User) # TypedloadValueError: Value does not contain fields: {'nickname'} which are necessary for type User # Those 2 work fine typedload.load({'username': 'ltworf', 'nickname': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': 'LtWorf'}, User) # Out: User(username='ltworf', nickname='LtWorf', last_login=None) # Those 2 work fine too typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': 666}, User) # Out: User(username='ltworf', nickname=None, last_login=666) There is of course no relationship between a default value and Optional , so a default can be anything. class Coordinates(NamedTuple): x: int = 0 y: int = 0 When dumping values, the fields which match with their default value are omitted. # Returns an empty dictionary typedload.dump(Coordinates()) # Out: {} # Returns only the x value typedload.dump(Coordinates(x=42, y=0)) # Out: {'x': 42} # Returns both coordinates typedload.dump(Coordinates(), hidedefault=False) # Out: {'x': 0, 'y': 0}","title":"Optional values"},{"location":"examples/#unions","text":"","title":"Unions"},{"location":"examples/#disable-cast","text":"Many times it is beneficial to disable casting when loading. For example, if a value can be an object of a certain kind or a string, not disabling casting will cast any invalid object to a string, which might not be desired. import typedload from typing import NamedTuple, Union class Data(NamedTuple): data: int # This loads \"{'date': 33}\", since the object is not a valid Data object. typedload.load({'date': 33}, Union[str, Data]) # Out: \"{'date': 33}\" # This fails, because the dictionary is not cast to str typedload.load({'date': 33}, Union[str, Data], basiccast=False) # TypedloadValueError: Value of dict could not be loaded into typing.Union[str, __main__.Data]","title":"Disable cast"},{"location":"examples/#list-or-single-object","text":"Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_points # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points # Out: [Point(x=1.4, y=4.1), Point(x=5.2, y=6.13)] typedload.load(data1, Data).data_points # Out: [Point(x=1.4, y=4.1)] typedload.load(data2, Data).data_points # Out: []","title":"List or single object"},{"location":"examples/#objects_1","text":"Loading different objects with a Union is of course possible, but some care is needed to avoid unexpected results. For example, using objects with default values is a bad idea: import typedload from typing import NamedTuple, Union, Optional class Person(NamedTuple): name: str = '' class Data(NamedTuple): data: Optional[str] = None # WARNING: This might return either a Person or a Data. It's random typedload.load({}, Union[Person, Data]) # Out: Data(data=None) # Out: Person(name='') This happens because in the union the order of the type is random, and either object works fine. So you want to use union on objects that have at least one non default non colliding field. You might want to use failonextra for objects whose fields are subset of other objects. import typedload from typing import NamedTuple, Union class Person(NamedTuple): name: str class Car(NamedTuple): name: str model: str # This should be a Car, not a Person data = {'name': 'macchina', 'model': 'TP21'} # WARNING: This can return either a Person or a Car typedload.load(data, Union[Person, Car]) # Out: Person(name='macchina') # Out: Car(name='macchina', model='TP21') # This can be explained by checking that both of these work typedload.load(data, Person) # Out: Person(name='macchina') typedload.load(data, Car) # Out: Car(name='macchina', model='TP21') # The data we have works for both objects, and the union # picks the first one (python sorts them randomly) # We want to avoid that dictionary to be loaded as Person, so we use failonextra # This fails typedload.load(data, Person, failonextra=True) # TypedloadValueError: Dictionary has unrecognized fields: model and cannot be loaded into Person # This works typedload.load(data, Car, failonextra=True) # Out: Car(name='macchina', model='TP21') # At this point the union will reliably pick the class that we want typedload.load(data, Union[Person, Car], failonextra=True) # Out: Car(name='macchina', model='TP21')","title":"Objects"},{"location":"examples/#object-type-in-value","text":"Let's assume that our json objects contain a type field that names the object itself. This makes conflicts impossible and so in the union the correct type will always be picked. Slack sends events in this way. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) # Out: [Message(type='message', text='hello'), UserJoined(type='user-joined', username='giuf\u00e0')]","title":"Object type in value"},{"location":"examples/#name-mangling","text":"Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') When dumping back the data typedload.dump(character) # Out: {'lastName': 'Paperino', 'firstName': 'Paolino'} the names will be converted back to camel case.","title":"Name mangling"},{"location":"examples/#multiple-name-mangling-schemes","text":"If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') typedload.dump(character, mangle_key='alt_name') # Out: {'last-name': 'Paperino', 'first-name': 'Paolino'}","title":"Multiple name mangling schemes"},{"location":"examples/#load-and-dump-types-from-str","text":"Some classes are easy to load and dump from str . For example this is done for Path . Let's assume we want to have a class that is called SerialNumber that we load from a string and dump back to a string. Here's how it can be done: from typing import List import typedload.datadumper import typedload.dataloader class SerialNumber: def __init__(self, sn: str) -> None: # Some validation if ' ' in sn: raise Exception('Invalid serial number') self.sn = sn def __str__(self): return self.sn l = typedload.dataloader.Loader() d = typedload.datadumper.Dumper() l.strconstructed.add(SerialNumber) d.strconstructed.add(SerialNumber) serials = l.load(['1', '2', '3'], List[SerialNumber]) d.dump(serials)","title":"Load and dump types from str"},{"location":"examples/#custom-handlers","text":"Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something.","title":"Custom handlers"},{"location":"origin_story/","text":"typedload's origin story At $DAYJOB there was a software written in Scala, that worked by mapping objects into mongodb data. The only one person there knowing Scala decided to quit, and so we were in the process of rewriting the entire thing in Python. I had been tasked to write a few hundreds methods to_json() and from_json() for all the various objects that are used by this software. Since I thought it was going to be a terribly boring job in which I'd make tens of typos, I looked for a library that did such a thing. But of course none existed, so I started writing a module to do that. The to_json() part was rather easy, while the opposite wasn't, anyway after a few days the module seemed to be working nice. The module in fact worked so nicely that I wanted to use it in my personal projects as well. However I couldn't, as I had written it at $DAYJOB and I knew that getting the authorization to release it as open source would take from 2 years to +\u221e. So, I just wrote a stand alone library outside of work to do the exact same thing, but in a more generic and flexible way, rather than tied to the specific software we had at $DAYJOB. The result of writing the same library twice was that the second time around it came out better, and so the original version got completely discarded and at $DAYJOB typedload is now in use.","title":"Origin story"},{"location":"origin_story/#typedloads-origin-story","text":"At $DAYJOB there was a software written in Scala, that worked by mapping objects into mongodb data. The only one person there knowing Scala decided to quit, and so we were in the process of rewriting the entire thing in Python. I had been tasked to write a few hundreds methods to_json() and from_json() for all the various objects that are used by this software. Since I thought it was going to be a terribly boring job in which I'd make tens of typos, I looked for a library that did such a thing. But of course none existed, so I started writing a module to do that. The to_json() part was rather easy, while the opposite wasn't, anyway after a few days the module seemed to be working nice. The module in fact worked so nicely that I wanted to use it in my personal projects as well. However I couldn't, as I had written it at $DAYJOB and I knew that getting the authorization to release it as open source would take from 2 years to +\u221e. So, I just wrote a stand alone library outside of work to do the exact same thing, but in a more generic and flexible way, rather than tied to the specific software we had at $DAYJOB. The result of writing the same library twice was that the second time around it came out better, and so the original version got completely discarded and at $DAYJOB typedload is now in use.","title":"typedload's origin story"},{"location":"supported_types/","text":"Supported types None typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself. Basic types By default: {int, bool, float, str, NONETYPE} Those types are te basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1 typing.Literal typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union . It is very common to use Literal to disambiguate objects in a Union. See example enum.Enum class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used. typing.List In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list. typing.Tuple Always dumped as a list. Finite size tuple In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError Infinite size tuple In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size. typing.Dict In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct. Objects typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr.ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) total: int = field(init=False) def __post_init__(self): self.total = 123 # calculation here In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)], total=123) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped. Forward references A forward reference is when a type is specified as a string instead of as an object: a: ObjA = ObjA() a: 'ObjA' = ObjA() The 2nd generates a forward reference, that is, a fake type that is really hard to resolve. The current strategy for typedload is to cache all the names of the types it encounters and use this cache to resolve the names. In alternative, it is possible to use the frefs dictionary to manually force resolution for a particular type. Python typing module offers some ways to resolve those types which are not used at the moment because they are slow and have strong limitations. Python developers want to turn every type annotation into a forward reference, for speed reasons. This was supposed to come in 3.10 but has been postponed. So for the moment there is little point into working on this very volatile API. typing.Union A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime. Optional A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None Ambiguity Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1) Finding ambiguity Typedload can't solve certain ambiguities, but setting uniondebugconflict=True will help detect them. In : typedload.load({}, Union[A, B], uniondebugconflict=True) TypedloadTypeError: Value of dict could be loaded into typing.Union[__main__.A, __main__.B] multiple times So this setting can be used to find ambiguities and manually correct them. NOTE : The setting slows down the loading of unions, so it is recommended to use it only during tests or when designing the data structures, but not in production. typing.TypedDict class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected. It also supports non-total TypedDict (since 2.7). class A(TypedDict, total=False): val: str In [5]: typedload.load({}, A) Out[5]: {} typing.Set, typing.Frozenset In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list. typing.Any typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed. String constructed Loaders and dumpers have a set of strconstructed . Those are types that accept a single str parameter in their constructor and have a __str__ method that returns that parameter. For those types, a specific handler is not needed and they can just be added to the strconstructed set. The preset ones are: pathlib.Path In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string. ipaddress.IPv*Address/Network/Interface ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string. argparse.Namespace This is converted to a dictionary and can be loaded into NamedTuple/dataclass. Dates datetime.date datetime.time datetime.datetime TODO","title":"Supported types"},{"location":"supported_types/#supported-types","text":"","title":"Supported types"},{"location":"supported_types/#none","text":"typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself.","title":"None"},{"location":"supported_types/#basic-types","text":"By default: {int, bool, float, str, NONETYPE} Those types are te basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1","title":"Basic types"},{"location":"supported_types/#typingliteral","text":"typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union . It is very common to use Literal to disambiguate objects in a Union. See example","title":"typing.Literal"},{"location":"supported_types/#enumenum","text":"class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used.","title":"enum.Enum"},{"location":"supported_types/#typinglist","text":"In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list.","title":"typing.List"},{"location":"supported_types/#typingtuple","text":"Always dumped as a list.","title":"typing.Tuple"},{"location":"supported_types/#finite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError","title":"Finite size tuple"},{"location":"supported_types/#infinite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size.","title":"Infinite size tuple"},{"location":"supported_types/#typingdict","text":"In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct.","title":"typing.Dict"},{"location":"supported_types/#objects","text":"typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr.ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) total: int = field(init=False) def __post_init__(self): self.total = 123 # calculation here In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)], total=123) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped.","title":"Objects"},{"location":"supported_types/#forward-references","text":"A forward reference is when a type is specified as a string instead of as an object: a: ObjA = ObjA() a: 'ObjA' = ObjA() The 2nd generates a forward reference, that is, a fake type that is really hard to resolve. The current strategy for typedload is to cache all the names of the types it encounters and use this cache to resolve the names. In alternative, it is possible to use the frefs dictionary to manually force resolution for a particular type. Python typing module offers some ways to resolve those types which are not used at the moment because they are slow and have strong limitations. Python developers want to turn every type annotation into a forward reference, for speed reasons. This was supposed to come in 3.10 but has been postponed. So for the moment there is little point into working on this very volatile API.","title":"Forward references"},{"location":"supported_types/#typingunion","text":"A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime.","title":"typing.Union"},{"location":"supported_types/#optional","text":"A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None","title":"Optional"},{"location":"supported_types/#ambiguity","text":"Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1)","title":"Ambiguity"},{"location":"supported_types/#finding-ambiguity","text":"Typedload can't solve certain ambiguities, but setting uniondebugconflict=True will help detect them. In : typedload.load({}, Union[A, B], uniondebugconflict=True) TypedloadTypeError: Value of dict could be loaded into typing.Union[__main__.A, __main__.B] multiple times So this setting can be used to find ambiguities and manually correct them. NOTE : The setting slows down the loading of unions, so it is recommended to use it only during tests or when designing the data structures, but not in production.","title":"Finding ambiguity"},{"location":"supported_types/#typingtypeddict","text":"class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected. It also supports non-total TypedDict (since 2.7). class A(TypedDict, total=False): val: str In [5]: typedload.load({}, A) Out[5]: {}","title":"typing.TypedDict"},{"location":"supported_types/#typingset-typingfrozenset","text":"In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list.","title":"typing.Set, typing.Frozenset"},{"location":"supported_types/#typingany","text":"typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed.","title":"typing.Any"},{"location":"supported_types/#string-constructed","text":"Loaders and dumpers have a set of strconstructed . Those are types that accept a single str parameter in their constructor and have a __str__ method that returns that parameter. For those types, a specific handler is not needed and they can just be added to the strconstructed set. The preset ones are:","title":"String constructed"},{"location":"supported_types/#pathlibpath","text":"In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string.","title":"pathlib.Path"},{"location":"supported_types/#ipaddressipvaddressnetworkinterface","text":"ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string.","title":"ipaddress.IPv*Address/Network/Interface"},{"location":"supported_types/#argparsenamespace","text":"This is converted to a dictionary and can be loaded into NamedTuple/dataclass.","title":"argparse.Namespace"},{"location":"supported_types/#dates","text":"datetime.date datetime.time datetime.datetime TODO","title":"Dates"}]}