{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typedload Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. Note that it is released with a GPL license. Example For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data) Supported types Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any Using Mypy # This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format. Install pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases Documentation Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module. Used by As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Home"},{"location":"#typedload","text":"Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. Note that it is released with a GPL license.","title":"typedload"},{"location":"#example","text":"For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data)","title":"Example"},{"location":"#supported-types","text":"Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any","title":"Supported types"},{"location":"#using-mypy","text":"# This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format.","title":"Using Mypy"},{"location":"#install","text":"pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases","title":"Install"},{"location":"#documentation","text":"Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module.","title":"Documentation"},{"location":"#used-by","text":"As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Used by"},{"location":"CHANGELOG/","text":"2.6 * Handle Any types as passthrough 2.5 * Fix dump for attr classes with factory * Let name mangling use arbitrary metadata fields rather than just 'name' 2.4 * Support for ipaddress.IPv4Address, ipaddress.IPv6Address, ipaddress.IPv4Network, ipaddress.IPv6Network, ipaddress.IPv4Interface, ipaddress.IPv6Interface. 2.3 * Better type sorting in Union This helps when using Union[dataclass, str] 2.2 * Add Python3.9 to the supported versions * Prevent loading dict as List,Tuple,Set This helps when using Union[Dict, List] to take the correct type. 2.1 * Written new usage example * typechecks internals now pass with more mypy configurations * Fix import * 2.0 * Breaking API change: handlers can only be modified before the first load * Breaking API change: plugins removed (attr support is by default) * Exceptions contain more information * Greatly improve performances with iterables types * Support for pathlib.Path 1.20 * Drop support for Python 3.5.2 (3.5 series is still supported) * Support TypedDict * More precise type annotation of TypedloadException and Annotation fields * Deprecate the plugin to handle attr.s and make it always supported. This means that there will be no need for special code. * Fix datetime loader raising exceptions with the wrong type 1.19 * Add support for Literal. 1.18 * Improved documentation * Debian builds are now done source only 1.17 * Prefer the same type in union loading 1.16 * New uniontypes() function. * Make list and dictionary loaders raise the correct exceptions * Able to load from argparse.Namespace 1.15 * Add support for FrozenSet[T]. * Define all for typechecks. * Add name mangling support in dataclass, to match attrs. * Add support for datetime.date, datetime.time, datetime.datetime 1.14 * Add support for Tuple[t, ...] 1.13 * Fix bug in loading attr classes and passing random crap. Now the proper exception is raised. * New module to expose the internal type checks functions 1.12 * Support fields with factory for dataclass 1.11 * Fixed problem when printing sub-exceptions of failed unions * Improve documentation 1.10 * Make mypy happy again 1.9 * Support ForwardRef * Add a new Exception type with more details on the error (no breaking API changes) 1.8 * Make mypy happy again 1.7 * Make mypy happy again 1.6 * Run tests on older python as well * Support for dataclass (Since python 3.7) * Added methods to find the appropriate handlers 1.5 * Improve handling of unions * Better continuous integration * Support python 3.7 1.4 * Add support for name mangling in attr plugin * Parameters can be passed as kwargs * Improved exception message for NamedTuple loading 1.3 * Add support for Python < 3.5.3 1.2 * Ship the plugins in pypy 1.1 * Able to load and dump old style NamedTuple * Support for Python 3.5 * Target to run mypy in makefile * Refactor to support plugins. The API is still compatible. * Plugin for the attr module, seems useful in Python 3.5 1.0 * Has a setting to hide default fields or not, in dumps * Better error reporting * Add file for PEP 561 0.9 * Initial release","title":"CHANGELOG"},{"location":"CONTRIBUTING/","text":"All contributions must pass the test suite and must generate no warnings with the latest available version of mypy. The best way of sending changes is to use git-send-mail to tiposchi@tiscali.it It is acceptable also to use github's pull request functionality. Contributors must accept that their changes can use both GPL3 and LGPL3. Currently the license is GPL3 with one exception being made for the company where I work. In the future more LGPL3 exception could be made, but no other license than those will be used.","title":"Contributing"},{"location":"SECURITY/","text":"Security Policy I do not expect any security issues in this package, but just to make github happy. Supported Versions Only the latest release is supported. I will not backport fixes. Reporting a Vulnerability Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Security Policy"},{"location":"SECURITY/#security-policy","text":"I do not expect any security issues in this package, but just to make github happy.","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"Only the latest release is supported. I will not backport fixes.","title":"Supported Versions"},{"location":"SECURITY/#reporting-a-vulnerability","text":"Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Reporting a Vulnerability"},{"location":"comparisons/","text":"Comparisons In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: It works with existing codebase Most libraries require your classes to extend or use decorators from the library itself. Instead, typedload works fine with the type annotations from the typing module and will work without requiring changes to the datatypes. It is easy to extend Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases. pydantic Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Does not handle Union, Set, Path dataclasses-json Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"Comparisons"},{"location":"comparisons/#comparisons","text":"In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are:","title":"Comparisons"},{"location":"comparisons/#it-works-with-existing-codebase","text":"Most libraries require your classes to extend or use decorators from the library itself. Instead, typedload works fine with the type annotations from the typing module and will work without requiring changes to the datatypes.","title":"It works with existing codebase"},{"location":"comparisons/#it-is-easy-to-extend","text":"Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases.","title":"It is easy to extend"},{"location":"comparisons/#pydantic","text":"Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Does not handle Union, Set, Path","title":"pydantic"},{"location":"comparisons/#dataclasses-json","text":"Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"dataclasses-json"},{"location":"examples/","text":"Examples Objects TODO Optional values TODO Unions Disable cast TODO List or single object Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_point # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points typedload.load(data1, Data).data_points typedload.load(data2, Data).data_points Objects TODO Object type in value Let's assume that our json objects contain a type field that names the object itself. Slack sends events in this way for example. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) Name mangling Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) When dumping back the data typedload.dump(character) the names will be converted back to camel case. Multiple name mangling schemes If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) typedload.dump(character, mangle_key='alt_name') Custom handlers Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something. Exceptions TODO","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#objects","text":"TODO","title":"Objects"},{"location":"examples/#optional-values","text":"TODO","title":"Optional values"},{"location":"examples/#unions","text":"","title":"Unions"},{"location":"examples/#disable-cast","text":"TODO","title":"Disable cast"},{"location":"examples/#list-or-single-object","text":"Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_point # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points typedload.load(data1, Data).data_points typedload.load(data2, Data).data_points","title":"List or single object"},{"location":"examples/#objects_1","text":"TODO","title":"Objects"},{"location":"examples/#object-type-in-value","text":"Let's assume that our json objects contain a type field that names the object itself. Slack sends events in this way for example. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]])","title":"Object type in value"},{"location":"examples/#name-mangling","text":"Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) When dumping back the data typedload.dump(character) the names will be converted back to camel case.","title":"Name mangling"},{"location":"examples/#multiple-name-mangling-schemes","text":"If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) typedload.dump(character, mangle_key='alt_name')","title":"Multiple name mangling schemes"},{"location":"examples/#custom-handlers","text":"Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something.","title":"Custom handlers"},{"location":"examples/#exceptions","text":"TODO","title":"Exceptions"},{"location":"origin_story/","text":"typedload's origin story","title":"Origin story"},{"location":"origin_story/#typedloads-origin-story","text":"","title":"typedload's origin story"},{"location":"supported_types/","text":"Supported types None typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself. Basic types By default: {int, bool, float, str, NONETYPE} Those types are te basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1 typing.Literal typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union . enum.Enum class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used. typing.List In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list. typing.Tuple Always dumped as a list. Finite size tuple In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError Infinite size tuple In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size. typing.Dict In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct. Objects typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr-ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)]) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped. Forward references TODO typing.Union A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime. Optional A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None Ambiguity Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1) typing.TypedDict class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected. typing.Set, typing.Frozenset In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list. typing.Any typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed. pathlib.Path In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string. ipaddress.IPv*Address/Network/Interface ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string. argparse.Namespace This is converted to a dictionary and can be loaded into NamedTuple/dataclass. Dates datetime.date datetime.time datetime.datetime TODO","title":"Supported types"},{"location":"supported_types/#supported-types","text":"","title":"Supported types"},{"location":"supported_types/#none","text":"typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself.","title":"None"},{"location":"supported_types/#basic-types","text":"By default: {int, bool, float, str, NONETYPE} Those types are te basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1","title":"Basic types"},{"location":"supported_types/#typingliteral","text":"typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union .","title":"typing.Literal"},{"location":"supported_types/#enumenum","text":"class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used.","title":"enum.Enum"},{"location":"supported_types/#typinglist","text":"In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list.","title":"typing.List"},{"location":"supported_types/#typingtuple","text":"Always dumped as a list.","title":"typing.Tuple"},{"location":"supported_types/#finite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError","title":"Finite size tuple"},{"location":"supported_types/#infinite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size.","title":"Infinite size tuple"},{"location":"supported_types/#typingdict","text":"In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct.","title":"typing.Dict"},{"location":"supported_types/#objects","text":"typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr-ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)]) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped.","title":"Objects"},{"location":"supported_types/#forward-references","text":"TODO","title":"Forward references"},{"location":"supported_types/#typingunion","text":"A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime.","title":"typing.Union"},{"location":"supported_types/#optional","text":"A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None","title":"Optional"},{"location":"supported_types/#ambiguity","text":"Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1)","title":"Ambiguity"},{"location":"supported_types/#typingtypeddict","text":"class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected.","title":"typing.TypedDict"},{"location":"supported_types/#typingset-typingfrozenset","text":"In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list.","title":"typing.Set, typing.Frozenset"},{"location":"supported_types/#typingany","text":"typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed.","title":"typing.Any"},{"location":"supported_types/#pathlibpath","text":"In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string.","title":"pathlib.Path"},{"location":"supported_types/#ipaddressipvaddressnetworkinterface","text":"ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string.","title":"ipaddress.IPv*Address/Network/Interface"},{"location":"supported_types/#argparsenamespace","text":"This is converted to a dictionary and can be loaded into NamedTuple/dataclass.","title":"argparse.Namespace"},{"location":"supported_types/#dates","text":"datetime.date datetime.time datetime.datetime TODO","title":"Dates"}]}