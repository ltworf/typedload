{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"typedload Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. It is released with a GPLv3 license but it is possible to ask for LGPLv3 . Example For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data) Supported types Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any typing.NewType Unions typedload works fine with untagged unions. However using Literal fields to tag them makes it much faster. Using Mypy Mypy and similar tools work without requiring any plugins. # This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format. Extending Type handlers can easily be added, and existing ones can be replaced, so the library is fully cusomizable and can work with any type. Inheriting a base class is not required. Install pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases Documentation Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module. Used by As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world (via Relational ) People who love IRC (via localslackirc ) No clue but it gets thousands of downloads per day according to pypi","title":"Home"},{"location":"index.html#typedload","text":"Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. It is released with a GPLv3 license but it is possible to ask for LGPLv3 .","title":"typedload"},{"location":"index.html#example","text":"For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data)","title":"Example"},{"location":"index.html#supported-types","text":"Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address typing.Any typing.NewType","title":"Supported types"},{"location":"index.html#unions","text":"typedload works fine with untagged unions. However using Literal fields to tag them makes it much faster.","title":"Unions"},{"location":"index.html#using-mypy","text":"Mypy and similar tools work without requiring any plugins. # This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format.","title":"Using Mypy"},{"location":"index.html#extending","text":"Type handlers can easily be added, and existing ones can be replaced, so the library is fully cusomizable and can work with any type. Inheriting a base class is not required.","title":"Extending"},{"location":"index.html#install","text":"pip install typedload apt install python3-typedload Latest and greatest .deb file is in releases","title":"Install"},{"location":"index.html#documentation","text":"Online documentation In the docs/ directory The tests are hard to read but provide more in depth examples of the capabilities of this module.","title":"Documentation"},{"location":"index.html#used-by","text":"As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world (via Relational ) People who love IRC (via localslackirc ) No clue but it gets thousands of downloads per day according to pypi","title":"Used by"},{"location":"CHANGELOG.html","text":"2.25 Improve performance for loading objects (attrs/dataclasses/NamedTuple) Improve performance for loading dictionary keys that are basic types Improve performance for loading dataclasses Switch performance tests to test against pydantic2 2.24 Drop support to Python 3.7 (which has reached EOL) Make is_optional slightly faster Keep track of the index when loading iterables the first time It makes the normal case slightly slower, and gives massive performance improvements when exceptions are raised. 2.23 When loading a string into datetime.date/time/datetime, ISO 8601 is used When dumping, setting isodates=True dumps an ISO 8601 string instead of a list of ints. The previous behaviour is now deprecated. Add support for datetime.timedelta. It is dumped as a float representing seconds Deprecate dump handlers without type hints Improve performance for dumping, by carrying type hints Remove jsons and dataclasses-json from benchmarks. They were too slow to be a useful comparison. 2.22 Improve loading time for literals Support attrs converter 2.21 Drop support to Python 3.5 and 3.6 Improve performance for dumping Generate pure python wheel 2.20 Switch to setuptools Since python decided to drop the only installation method available within the stdlib Add pyproject.toml 2.19 Fix minor bug about exception raising from string constructed types Simplify type checking functions, defining only the one for the current python version Fix type definitions of some private functions for compatibility with cython Improved loading speed for dictionaries Improved loading speed for iterators Improved documentation Improved performance testing code 2.18 Fix bug with loading generators that raise exceptions 2.17 Support for NotRequired Document performance testing Improve performances when loading iterables Greatly improve performances when loading Union of objects that are Literal annotated 2.16 Add is_optional function Support new style union (A | B) Experimental support for PEP563 __future__.annotations . READ ABOUT DEFERRED EVALUATION IN THE DOCUMENTATION. 2.15 Union fails immediately when a non typedload exception is found New make html target to generate the website Updated CONTRIBUTING file, with details about new licenses from the FSF Handle typing.NewType 2.14 Fix bug where AttributeError from name mangling caused an AssertionError 2.13 Separate and simpler handlers for NamedTuple, dataclass, attrs, TypedDict Allow duck typing when loading attr (allow any dict-like class to be used) Minor performance improvements 2.12 Add uniondebugconflict flag to detect unions with conflicts. 2.11 Make newer mypy happy 2.10 Fix setup.py referring to a non-existing file when installing with pip 2.9 Use README on pypi.org Tiny speed improvement Expanded and improved documentation 2.8 Better report errors for Enum Improve support for inheritance with mixed totality of TypedDict (requires Python 3.9) 2.7 failonextra triggers failure when dropping fields in mangling Support for total=False in TypedDict Support init=False in dataclass field 2.6 Handle Any types as passthrough Easy way to handle types loaded from and dumped to str Improve how exceptions are displayed 2.5 Fix dump for attr classes with factory Let name mangling use arbitrary metadata fields rather than just name 2.4 Support for ipaddress.IPv4Address , ipaddress.IPv6Address , ipaddress.IPv4Network , ipaddress.IPv6Network , ipaddress.IPv4Interface , ipaddress.IPv6Interface . 2.3 Better type sorting in Union This helps when using Union[dataclass, str] 2.2 Add Python3.9 to the supported versions Prevent loading dict as List , Tuple , Set This helps when using Union[Dict, List] to take the correct type. 2.1 Written new usage example typechecks internals now pass with more mypy configurations Fix import * 2.0 Breaking API change: handlers can only be modified before the first load Breaking API change: plugins removed (attr support is by default) Exceptions contain more information Greatly improve performances with iterables types Support for pathlib.Path 1.20 Drop support for Python 3.5.2 (3.5 series is still supported) Support TypedDict More precise type annotation of TypedloadException and Annotation fields Deprecate the plugin to handle attr.s and make it always supported. This means that there will be no need for special code. Fix datetime loader raising exceptions with the wrong type 1.19 Add support for Literal . 1.18 Improved documentation Debian builds are now done source only 1.17 Prefer the same type in union loading 1.16 New uniontypes() function. Make list and dictionary loaders raise the correct exceptions Able to load from argparse.Namespace 1.15 Add support for FrozenSet[T] . Define __all__ for typechecks. Add name mangling support in dataclass, to match attrs. Add support for datetime.date , datetime.time , datetime.datetime 1.14 Add support for Tuple[t, ...] 1.13 Fix bug in loading attr classes and passing random crap. Now the proper exception is raised. New module to expose the internal type checks functions 1.12 Support fields with factory for dataclass 1.11 Fixed problem when printing sub-exceptions of failed unions Improve documentation 1.10 Make mypy happy again 1.9 Support ForwardRef Add a new Exception type with more details on the error (no breaking API changes) 1.8 Make mypy happy again 1.7 Make mypy happy again 1.6 Run tests on older python as well Support for dataclass (Since python 3.7) Added methods to find the appropriate handlers 1.5 Improve handling of unions Better continuous integration Support python 3.7 1.4 Add support for name mangling in attr plugin Parameters can be passed as kwargs Improved exception message for NamedTuple loading 1.3 Add support for Python < 3.5.3 1.2 Ship the plugins in pypy 1.1 Able to load and dump old style NamedTuple Support for Python 3.5 Target to run mypy in makefile Refactor to support plugins. The API is still compatible. Plugin for the attr module, seems useful in Python 3.5 1.0 Has a setting to hide default fields or not, in dumps Better error reporting Add file for PEP 561 0.9 Initial release","title":"Changelog"},{"location":"CHANGELOG.html#225","text":"Improve performance for loading objects (attrs/dataclasses/NamedTuple) Improve performance for loading dictionary keys that are basic types Improve performance for loading dataclasses Switch performance tests to test against pydantic2","title":"2.25"},{"location":"CHANGELOG.html#224","text":"Drop support to Python 3.7 (which has reached EOL) Make is_optional slightly faster Keep track of the index when loading iterables the first time It makes the normal case slightly slower, and gives massive performance improvements when exceptions are raised.","title":"2.24"},{"location":"CHANGELOG.html#223","text":"When loading a string into datetime.date/time/datetime, ISO 8601 is used When dumping, setting isodates=True dumps an ISO 8601 string instead of a list of ints. The previous behaviour is now deprecated. Add support for datetime.timedelta. It is dumped as a float representing seconds Deprecate dump handlers without type hints Improve performance for dumping, by carrying type hints Remove jsons and dataclasses-json from benchmarks. They were too slow to be a useful comparison.","title":"2.23"},{"location":"CHANGELOG.html#222","text":"Improve loading time for literals Support attrs converter","title":"2.22"},{"location":"CHANGELOG.html#221","text":"Drop support to Python 3.5 and 3.6 Improve performance for dumping Generate pure python wheel","title":"2.21"},{"location":"CHANGELOG.html#220","text":"Switch to setuptools Since python decided to drop the only installation method available within the stdlib Add pyproject.toml","title":"2.20"},{"location":"CHANGELOG.html#219","text":"Fix minor bug about exception raising from string constructed types Simplify type checking functions, defining only the one for the current python version Fix type definitions of some private functions for compatibility with cython Improved loading speed for dictionaries Improved loading speed for iterators Improved documentation Improved performance testing code","title":"2.19"},{"location":"CHANGELOG.html#218","text":"Fix bug with loading generators that raise exceptions","title":"2.18"},{"location":"CHANGELOG.html#217","text":"Support for NotRequired Document performance testing Improve performances when loading iterables Greatly improve performances when loading Union of objects that are Literal annotated","title":"2.17"},{"location":"CHANGELOG.html#216","text":"Add is_optional function Support new style union (A | B) Experimental support for PEP563 __future__.annotations . READ ABOUT DEFERRED EVALUATION IN THE DOCUMENTATION.","title":"2.16"},{"location":"CHANGELOG.html#215","text":"Union fails immediately when a non typedload exception is found New make html target to generate the website Updated CONTRIBUTING file, with details about new licenses from the FSF Handle typing.NewType","title":"2.15"},{"location":"CHANGELOG.html#214","text":"Fix bug where AttributeError from name mangling caused an AssertionError","title":"2.14"},{"location":"CHANGELOG.html#213","text":"Separate and simpler handlers for NamedTuple, dataclass, attrs, TypedDict Allow duck typing when loading attr (allow any dict-like class to be used) Minor performance improvements","title":"2.13"},{"location":"CHANGELOG.html#212","text":"Add uniondebugconflict flag to detect unions with conflicts.","title":"2.12"},{"location":"CHANGELOG.html#211","text":"Make newer mypy happy","title":"2.11"},{"location":"CHANGELOG.html#210","text":"Fix setup.py referring to a non-existing file when installing with pip","title":"2.10"},{"location":"CHANGELOG.html#29","text":"Use README on pypi.org Tiny speed improvement Expanded and improved documentation","title":"2.9"},{"location":"CHANGELOG.html#28","text":"Better report errors for Enum Improve support for inheritance with mixed totality of TypedDict (requires Python 3.9)","title":"2.8"},{"location":"CHANGELOG.html#27","text":"failonextra triggers failure when dropping fields in mangling Support for total=False in TypedDict Support init=False in dataclass field","title":"2.7"},{"location":"CHANGELOG.html#26","text":"Handle Any types as passthrough Easy way to handle types loaded from and dumped to str Improve how exceptions are displayed","title":"2.6"},{"location":"CHANGELOG.html#25","text":"Fix dump for attr classes with factory Let name mangling use arbitrary metadata fields rather than just name","title":"2.5"},{"location":"CHANGELOG.html#24","text":"Support for ipaddress.IPv4Address , ipaddress.IPv6Address , ipaddress.IPv4Network , ipaddress.IPv6Network , ipaddress.IPv4Interface , ipaddress.IPv6Interface .","title":"2.4"},{"location":"CHANGELOG.html#23","text":"Better type sorting in Union This helps when using Union[dataclass, str]","title":"2.3"},{"location":"CHANGELOG.html#22","text":"Add Python3.9 to the supported versions Prevent loading dict as List , Tuple , Set This helps when using Union[Dict, List] to take the correct type.","title":"2.2"},{"location":"CHANGELOG.html#21","text":"Written new usage example typechecks internals now pass with more mypy configurations Fix import *","title":"2.1"},{"location":"CHANGELOG.html#20","text":"Breaking API change: handlers can only be modified before the first load Breaking API change: plugins removed (attr support is by default) Exceptions contain more information Greatly improve performances with iterables types Support for pathlib.Path","title":"2.0"},{"location":"CHANGELOG.html#120","text":"Drop support for Python 3.5.2 (3.5 series is still supported) Support TypedDict More precise type annotation of TypedloadException and Annotation fields Deprecate the plugin to handle attr.s and make it always supported. This means that there will be no need for special code. Fix datetime loader raising exceptions with the wrong type","title":"1.20"},{"location":"CHANGELOG.html#119","text":"Add support for Literal .","title":"1.19"},{"location":"CHANGELOG.html#118","text":"Improved documentation Debian builds are now done source only","title":"1.18"},{"location":"CHANGELOG.html#117","text":"Prefer the same type in union loading","title":"1.17"},{"location":"CHANGELOG.html#116","text":"New uniontypes() function. Make list and dictionary loaders raise the correct exceptions Able to load from argparse.Namespace","title":"1.16"},{"location":"CHANGELOG.html#115","text":"Add support for FrozenSet[T] . Define __all__ for typechecks. Add name mangling support in dataclass, to match attrs. Add support for datetime.date , datetime.time , datetime.datetime","title":"1.15"},{"location":"CHANGELOG.html#114","text":"Add support for Tuple[t, ...]","title":"1.14"},{"location":"CHANGELOG.html#113","text":"Fix bug in loading attr classes and passing random crap. Now the proper exception is raised. New module to expose the internal type checks functions","title":"1.13"},{"location":"CHANGELOG.html#112","text":"Support fields with factory for dataclass","title":"1.12"},{"location":"CHANGELOG.html#111","text":"Fixed problem when printing sub-exceptions of failed unions Improve documentation","title":"1.11"},{"location":"CHANGELOG.html#110","text":"Make mypy happy again","title":"1.10"},{"location":"CHANGELOG.html#19","text":"Support ForwardRef Add a new Exception type with more details on the error (no breaking API changes)","title":"1.9"},{"location":"CHANGELOG.html#18","text":"Make mypy happy again","title":"1.8"},{"location":"CHANGELOG.html#17","text":"Make mypy happy again","title":"1.7"},{"location":"CHANGELOG.html#16","text":"Run tests on older python as well Support for dataclass (Since python 3.7) Added methods to find the appropriate handlers","title":"1.6"},{"location":"CHANGELOG.html#15","text":"Improve handling of unions Better continuous integration Support python 3.7","title":"1.5"},{"location":"CHANGELOG.html#14","text":"Add support for name mangling in attr plugin Parameters can be passed as kwargs Improved exception message for NamedTuple loading","title":"1.4"},{"location":"CHANGELOG.html#13","text":"Add support for Python < 3.5.3","title":"1.3"},{"location":"CHANGELOG.html#12","text":"Ship the plugins in pypy","title":"1.2"},{"location":"CHANGELOG.html#11","text":"Able to load and dump old style NamedTuple Support for Python 3.5 Target to run mypy in makefile Refactor to support plugins. The API is still compatible. Plugin for the attr module, seems useful in Python 3.5","title":"1.1"},{"location":"CHANGELOG.html#10","text":"Has a setting to hide default fields or not, in dumps Better error reporting Add file for PEP 561","title":"1.0"},{"location":"CHANGELOG.html#09","text":"Initial release","title":"0.9"},{"location":"CODE_OF_CONDUCT.html","text":"International code of conduct No USA cultural imperialism allowed This project welcomes every contributor from any background. For this reason we can't let the USA and USA influenced politically correct culture dictate conduct for everyone. Diversity is beautiful, let's not ask of people to forgo their culture to contribute. Achieving social justice is important. Being superficial about it only to feel morally superior is not the way to achieve it and is not tolerated here. The code of conduct only pertains this project This document only applies to the project and the communication channels. It does not apply to anything any contributor might say or do outside of project channels. It only applies to contributors. People whose only contribution is a code of conduct complaint are not contributors. Language Try to be nice and constructive. Harassing and intentionally offending other people is not allowed. Foul language is allowed. People often contribute to this project in their own time and are not paid, for this reason asking contributors to behave \"professionally\" makes no sense. Hobbies do not require professionality. Jokes are allowed. It can happen to unintentionally offend someone. Do not reiterate the offensive behaviour, provided that the request is reasonable. People who are easily offended by things not intended to be offensive must try to become more tolerant towards other people, other cultures and their ways of expressing themselves. For example, a person might consider offensive the sight of a woman with or without a headscarf. This person needs to try to become more tolerant to other people's culture. It is not allowed to be offended on behalf of others. Please do not presume to know what others are thinking. Examples of allowed language: This software is retarded This program runs like shit This bug is annoying Examples of disallowed language: You are retarded You are shitty and so is your program Skill discrimination is absolutely fine Unlike other code of conducts, this allows skill discrimination. Everyone is welcome to contribute according to their skill level and more experienced contributors are encouraged to act as mentors. It is nice if they have time and patience to mentor potential contributors, but since time is a limited resource, it is also fine to turn down low quality and low effort contributions with little explaination. New contributors are expected to respond to comments and be willing to improve the quality of their contribution. Conflict resolution This code of conduct is inevitably vague. Follow the intention rather than the letter. The final word rests with the project owners or their delegates. Changes to license It is not allowed to ask for license change and complain about copyleft. If you disagree with the license, feel free to start your own project from scratch without getting in touch and never look at the source code, to avoid copyright issues. See also International code of conduct","title":"Code of conduct"},{"location":"CODE_OF_CONDUCT.html#international-code-of-conduct","text":"","title":"International code of conduct"},{"location":"CODE_OF_CONDUCT.html#no-usa-cultural-imperialism-allowed","text":"This project welcomes every contributor from any background. For this reason we can't let the USA and USA influenced politically correct culture dictate conduct for everyone. Diversity is beautiful, let's not ask of people to forgo their culture to contribute. Achieving social justice is important. Being superficial about it only to feel morally superior is not the way to achieve it and is not tolerated here.","title":"No USA cultural imperialism allowed"},{"location":"CODE_OF_CONDUCT.html#the-code-of-conduct-only-pertains-this-project","text":"This document only applies to the project and the communication channels. It does not apply to anything any contributor might say or do outside of project channels. It only applies to contributors. People whose only contribution is a code of conduct complaint are not contributors.","title":"The code of conduct only pertains this project"},{"location":"CODE_OF_CONDUCT.html#language","text":"Try to be nice and constructive. Harassing and intentionally offending other people is not allowed. Foul language is allowed. People often contribute to this project in their own time and are not paid, for this reason asking contributors to behave \"professionally\" makes no sense. Hobbies do not require professionality. Jokes are allowed. It can happen to unintentionally offend someone. Do not reiterate the offensive behaviour, provided that the request is reasonable. People who are easily offended by things not intended to be offensive must try to become more tolerant towards other people, other cultures and their ways of expressing themselves. For example, a person might consider offensive the sight of a woman with or without a headscarf. This person needs to try to become more tolerant to other people's culture. It is not allowed to be offended on behalf of others. Please do not presume to know what others are thinking. Examples of allowed language: This software is retarded This program runs like shit This bug is annoying Examples of disallowed language: You are retarded You are shitty and so is your program","title":"Language"},{"location":"CODE_OF_CONDUCT.html#skill-discrimination-is-absolutely-fine","text":"Unlike other code of conducts, this allows skill discrimination. Everyone is welcome to contribute according to their skill level and more experienced contributors are encouraged to act as mentors. It is nice if they have time and patience to mentor potential contributors, but since time is a limited resource, it is also fine to turn down low quality and low effort contributions with little explaination. New contributors are expected to respond to comments and be willing to improve the quality of their contribution.","title":"Skill discrimination is absolutely fine"},{"location":"CODE_OF_CONDUCT.html#conflict-resolution","text":"This code of conduct is inevitably vague. Follow the intention rather than the letter. The final word rests with the project owners or their delegates.","title":"Conflict resolution"},{"location":"CODE_OF_CONDUCT.html#changes-to-license","text":"It is not allowed to ask for license change and complain about copyleft. If you disagree with the license, feel free to start your own project from scratch without getting in touch and never look at the source code, to avoid copyright issues.","title":"Changes to license"},{"location":"CODE_OF_CONDUCT.html#see-also","text":"International code of conduct","title":"See also"},{"location":"CONTRIBUTING.html","text":"Contributing All contributions must pass the test suite and must generate no warnings with the latest available version of mypy. The best way of sending changes is to use git-send-mail to tiposchi@tiscali.it It is acceptable also to use github's pull request functionality. Contributors must accept that their changes can use both GPL3 and LGPL3. Currently the license is GPL3 with one exception being made for the company where I work. In the future more LGPL3 exception could be made, but no other license than those will be used. In the event that new versions of GPL and LGPL licenses should be published by the Free Software Foundation (FSF) in the future, contributors must accept that their contribution might be licensed with those future versions of GPL and LGPL in addition to the current version. This will be decided by the owners of the project if and when new versions of the licenses are created and is not automatic, to prevent the case where a new board of the FSF should decide to abandon its mission and grant less freedom to the users. For new versions that aim at fixing corner cases (such as version 3), they will be used and the software will be available under multiple licenses versions (starting from 3). They will not be adopted should the FSF decide that GPL4 should be a non-copyleft license or other similar spirit altering changes.","title":"Contributing"},{"location":"CONTRIBUTING.html#contributing","text":"All contributions must pass the test suite and must generate no warnings with the latest available version of mypy. The best way of sending changes is to use git-send-mail to tiposchi@tiscali.it It is acceptable also to use github's pull request functionality. Contributors must accept that their changes can use both GPL3 and LGPL3. Currently the license is GPL3 with one exception being made for the company where I work. In the future more LGPL3 exception could be made, but no other license than those will be used. In the event that new versions of GPL and LGPL licenses should be published by the Free Software Foundation (FSF) in the future, contributors must accept that their contribution might be licensed with those future versions of GPL and LGPL in addition to the current version. This will be decided by the owners of the project if and when new versions of the licenses are created and is not automatic, to prevent the case where a new board of the FSF should decide to abandon its mission and grant less freedom to the users. For new versions that aim at fixing corner cases (such as version 3), they will be used and the software will be available under multiple licenses versions (starting from 3). They will not be adopted should the FSF decide that GPL4 should be a non-copyleft license or other similar spirit altering changes.","title":"Contributing"},{"location":"SECURITY.html","text":"Security Policy I do not expect any security issues in this package, but just to make github happy. Supported Versions Only the latest release is supported. I will not backport fixes. Reporting a Vulnerability Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Security Policy"},{"location":"SECURITY.html#security-policy","text":"I do not expect any security issues in this package, but just to make github happy.","title":"Security Policy"},{"location":"SECURITY.html#supported-versions","text":"Only the latest release is supported. I will not backport fixes.","title":"Supported Versions"},{"location":"SECURITY.html#reporting-a-vulnerability","text":"Contact me at tiposchi@tiscali.it My PGP key is on this file, on git. debian/upstream/signing-key.asc","title":"Reporting a Vulnerability"},{"location":"comparisons.html","text":"Comparisons In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: Works with existing codebase and uses standard types. No inheritance or decorators Easy to use Easy to extend, even with objects from 3rd party libraries Stable API, breaking changes only happen on major releases (it has happened once since 2018 and most users didn't notice) Supports Union properly Works on python 3.5 (until typedload <= 2.20) Mypy and similar work without plugins Can use and convert camelCase and snake_case Functional approach Pure Python, no compiling Very small, it's fast for automated tests to extract and install compared to huge binary libraries It works with existing codebase Most libraries require your classes to extend or use decorators from the library itself. This means that types from other libraries or non supported stdlib classes can never be used. It also means that mypy will just work out of the box, rather than requiring plugins. Instead, typedload works fine with the type annotations from the typing module and will work without requiring any changes to the datatypes. It also works on python 3.5 (until version 2.20), so projects running on LTS distributions can use it. It is easy to extend Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases. Support of Union Other libraries tend to either be very slow or just give completely wrong results when Union are involved. Functional approach You can load a List[YourType] , while pydantic can only load a single object that then will contain the list. apischema Found here It's the only viable alternative to typedload that I've encountered. Settings are global, a submodule changing a setting will affect the entire application Type checks are disabled by default It reuses the same objects in the output, so changing the data might result in subtle bugs if the input data is used again No native support for attrs (but can be manually added by the user) Faster than typedload for flat data structures, slower otherwise pydantic Found here The author calls you a liar if your pure python library is faster Breaks API all the time, between minor releases. (43 times in 2 major versions so far) They hate benchmarks that show it's slow . So they removed them altogether It needs a mypy plugin, and for some kinds of classes it does no static checks whatsoever. Is now related to a company that will need some way to monetize, eventually Version 1 One of the slowest libraries that exist in this space int | float might decide to cast a float to int , or an int to float Version 2 Somehow manages to be slower than pure python in certain benchmarks, despite months of work to rewrite it in rust Took them several years to make a version 2 where types on BaseModel finally mean the same thing that they mean in the rest of python Took them several years to implement unions to catch up with typedload jsons Found here Type safety is not a goal of this project It is buggy: This returns an int jsons.load(1.1, Union[int, float]) This returns a string jsons.load(1, Union[str, int]) This raises an exception jsons.load(1.0, int | float) It is incredibly slow (40x slower in certain cases) For this reason it has been removed from the benchmarks. Does not support Literal Can't load iterables as lists Exceptions do not have information to find the incorrect data Quick test # Needed because jsons can't load directly from range() data = [i for i in range(3000000)] # This took 2.5s with jsons and 200ms with typedload load(data, list[int]) # This took 20s with jsons and 500ms with typedload # And it converted all the ints to float! load(data, list[Union[float,int]]) dataclasses-json Found here It is completely useless for type safety and very slow. I can't understand why it has users. It is incredibly slow (20x slower in certain cases) For this reason it has been removed from the benchmarks. It doesn't enforce type safety (it will be happy to load whatever inside an int field) Requires to decorate all the classes It is not extensible Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists Quick test # Just to show how unreliable this is @dataclass_json @dataclass class Data: data: list[int] Data.from_dict({'data': [\"4\", None, ..., ('qwe',), 1.1]}) # This returns: # Data(data=['4', None, Ellipsis, ('qwe',), 1.1]) # despite data is supposed to be a list of int msgspec Found here Implemented in C, won't run on PyPy Supports tagged Unions partially only when inheriting from its Struct type Mypy will not typecheck those classes. To use unions you must give up static typechecking. Doesn't support unions between regular dataclass/NamedTuple/Attrs/TypedDict Doesn't support untagged Unions Doesn't support multiple tags (e.g. tag=Literal[1, 2] ) Extended using a single function that must handle all cases Can't replace type handlers","title":"Why typedload"},{"location":"comparisons.html#comparisons","text":"In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: Works with existing codebase and uses standard types. No inheritance or decorators Easy to use Easy to extend, even with objects from 3rd party libraries Stable API, breaking changes only happen on major releases (it has happened once since 2018 and most users didn't notice) Supports Union properly Works on python 3.5 (until typedload <= 2.20) Mypy and similar work without plugins Can use and convert camelCase and snake_case Functional approach Pure Python, no compiling Very small, it's fast for automated tests to extract and install compared to huge binary libraries","title":"Comparisons"},{"location":"comparisons.html#it-works-with-existing-codebase","text":"Most libraries require your classes to extend or use decorators from the library itself. This means that types from other libraries or non supported stdlib classes can never be used. It also means that mypy will just work out of the box, rather than requiring plugins. Instead, typedload works fine with the type annotations from the typing module and will work without requiring any changes to the datatypes. It also works on python 3.5 (until version 2.20), so projects running on LTS distributions can use it.","title":"It works with existing codebase"},{"location":"comparisons.html#it-is-easy-to-extend","text":"Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases.","title":"It is easy to extend"},{"location":"comparisons.html#support-of-union","text":"Other libraries tend to either be very slow or just give completely wrong results when Union are involved.","title":"Support of Union"},{"location":"comparisons.html#functional-approach","text":"You can load a List[YourType] , while pydantic can only load a single object that then will contain the list.","title":"Functional approach"},{"location":"comparisons.html#apischema","text":"Found here It's the only viable alternative to typedload that I've encountered. Settings are global, a submodule changing a setting will affect the entire application Type checks are disabled by default It reuses the same objects in the output, so changing the data might result in subtle bugs if the input data is used again No native support for attrs (but can be manually added by the user) Faster than typedload for flat data structures, slower otherwise","title":"apischema"},{"location":"comparisons.html#pydantic","text":"Found here The author calls you a liar if your pure python library is faster Breaks API all the time, between minor releases. (43 times in 2 major versions so far) They hate benchmarks that show it's slow . So they removed them altogether It needs a mypy plugin, and for some kinds of classes it does no static checks whatsoever. Is now related to a company that will need some way to monetize, eventually","title":"pydantic"},{"location":"comparisons.html#version-1","text":"One of the slowest libraries that exist in this space int | float might decide to cast a float to int , or an int to float","title":"Version 1"},{"location":"comparisons.html#version-2","text":"Somehow manages to be slower than pure python in certain benchmarks, despite months of work to rewrite it in rust Took them several years to make a version 2 where types on BaseModel finally mean the same thing that they mean in the rest of python Took them several years to implement unions to catch up with typedload","title":"Version 2"},{"location":"comparisons.html#jsons","text":"Found here Type safety is not a goal of this project It is buggy: This returns an int jsons.load(1.1, Union[int, float]) This returns a string jsons.load(1, Union[str, int]) This raises an exception jsons.load(1.0, int | float) It is incredibly slow (40x slower in certain cases) For this reason it has been removed from the benchmarks. Does not support Literal Can't load iterables as lists Exceptions do not have information to find the incorrect data","title":"jsons"},{"location":"comparisons.html#quick-test","text":"# Needed because jsons can't load directly from range() data = [i for i in range(3000000)] # This took 2.5s with jsons and 200ms with typedload load(data, list[int]) # This took 20s with jsons and 500ms with typedload # And it converted all the ints to float! load(data, list[Union[float,int]])","title":"Quick test"},{"location":"comparisons.html#dataclasses-json","text":"Found here It is completely useless for type safety and very slow. I can't understand why it has users. It is incredibly slow (20x slower in certain cases) For this reason it has been removed from the benchmarks. It doesn't enforce type safety (it will be happy to load whatever inside an int field) Requires to decorate all the classes It is not extensible Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"dataclasses-json"},{"location":"comparisons.html#quick-test_1","text":"# Just to show how unreliable this is @dataclass_json @dataclass class Data: data: list[int] Data.from_dict({'data': [\"4\", None, ..., ('qwe',), 1.1]}) # This returns: # Data(data=['4', None, Ellipsis, ('qwe',), 1.1]) # despite data is supposed to be a list of int","title":"Quick test"},{"location":"comparisons.html#msgspec","text":"Found here Implemented in C, won't run on PyPy Supports tagged Unions partially only when inheriting from its Struct type Mypy will not typecheck those classes. To use unions you must give up static typechecking. Doesn't support unions between regular dataclass/NamedTuple/Attrs/TypedDict Doesn't support untagged Unions Doesn't support multiple tags (e.g. tag=Literal[1, 2] ) Extended using a single function that must handle all cases Can't replace type handlers","title":"msgspec"},{"location":"deferred_evaluation.html","text":"Deferred evaluation PEP 563 defines deferred evaluation of types. It will most likely be superseeded by PEP 649 because of the following issues: eval() is slow eval() might not be present to save space only works for types defined at module level It is enabled with from __future__ import annotations . When it is enabled you must set pep563=True in your loader object, to (hopefully) make it keep working (it will not work in many corner cases). from __future__ import annotations class A(NamedTuple): a: Optional[int] load({'a':1}, A) # TypedloadValueError: ForwardRef 'Optional[int]' unknown load({'a':1}, A, pep563=True) # A(a=1) If you have such a simple case it will work fine. In more complicated cases it will not work. In those cases the solution is to not do the import. This feature will most likely be removed once the decision for the newer PEP is settled. It is not part of Python and you should not expect that typedload will keep it.","title":"Deferred evaluation of types"},{"location":"deferred_evaluation.html#deferred-evaluation","text":"PEP 563 defines deferred evaluation of types. It will most likely be superseeded by PEP 649 because of the following issues: eval() is slow eval() might not be present to save space only works for types defined at module level It is enabled with from __future__ import annotations . When it is enabled you must set pep563=True in your loader object, to (hopefully) make it keep working (it will not work in many corner cases). from __future__ import annotations class A(NamedTuple): a: Optional[int] load({'a':1}, A) # TypedloadValueError: ForwardRef 'Optional[int]' unknown load({'a':1}, A, pep563=True) # A(a=1) If you have such a simple case it will work fine. In more complicated cases it will not work. In those cases the solution is to not do the import. This feature will most likely be removed once the decision for the newer PEP is settled. It is not part of Python and you should not expect that typedload will keep it.","title":"Deferred evaluation"},{"location":"errors.html","text":"Errors in typedload All exceptions are subclasses of TypedloadException . To make sure of that, there is an assertion in place that will fail if a type handler is misbehaving and raising the wrong type of exception. The exceptions have a clear user message, but they offer an API to expose precise knowledge of the problem. String trace By default when an error occurrs the path within the data structure is shown. from typing import * import typedload class Thing(NamedTuple): value: int class Data(NamedTuple): field1: List[Thing] field2: Tuple[Thing, ...] typedload.load({'field1': [{'value': 12}, {'value': 'a'}], 'field2': []}, Data) TypedloadValueError: invalid literal for int() with base 10: 'a' Path: .field1.[1].value The path in the string description tells where the wrong value was found. Trace To be able to locate where in the data an exception happened, TypedloadException has the trace property, which contains a list TraceItem , which help to track where the exception happened. This can be useful to do more clever error handling. For example: try: typedload.load([1, 2, 'a'], List[int]) except Exception as e: print(e.trace[-1]) Will raise an exception and print the last element in the trace TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) Another example, with an object: class O(NamedTuple): data: List[int] try: typedload.load({'data': [1, 2, 'a']}, O) except Exception as e: for i in e.trace: print(i) Will print the entire trace: TraceItem(value={'data': [1, 2, 'a']}, type_=<class '__main__.O'>, annotation=None) TraceItem(value=[1, 2, 'a'], type_=typing.List[int], annotation=Annotation(annotation_type=<AnnotationType.FIELD: 'field'>, value='data')) TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) And checking the annotation field it is possible to find out that the issue happened in data at index 2 . Union Because it is normal for a union of n types to generate n-1 exceptions, a union which fails generated n exceptions. Typedload has no way of knowing which of those is the important exception that was expected to succeed and instead puts all the exceptions inside the exception field of the parent exception. So all the sub exceptions can be investigated to decide which one is the most relevant one. Raise exceptions in custom handlers To find the path where the wrong value was found, typedload needs to trace the execution by using annotations. This is used in handlers that do recursive calls to the loader. See the source code of the handlers for Union and NamedTuple to see how this is done.","title":"Errors"},{"location":"errors.html#errors-in-typedload","text":"All exceptions are subclasses of TypedloadException . To make sure of that, there is an assertion in place that will fail if a type handler is misbehaving and raising the wrong type of exception. The exceptions have a clear user message, but they offer an API to expose precise knowledge of the problem.","title":"Errors in typedload"},{"location":"errors.html#string-trace","text":"By default when an error occurrs the path within the data structure is shown. from typing import * import typedload class Thing(NamedTuple): value: int class Data(NamedTuple): field1: List[Thing] field2: Tuple[Thing, ...] typedload.load({'field1': [{'value': 12}, {'value': 'a'}], 'field2': []}, Data) TypedloadValueError: invalid literal for int() with base 10: 'a' Path: .field1.[1].value The path in the string description tells where the wrong value was found.","title":"String trace"},{"location":"errors.html#trace","text":"To be able to locate where in the data an exception happened, TypedloadException has the trace property, which contains a list TraceItem , which help to track where the exception happened. This can be useful to do more clever error handling. For example: try: typedload.load([1, 2, 'a'], List[int]) except Exception as e: print(e.trace[-1]) Will raise an exception and print the last element in the trace TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) Another example, with an object: class O(NamedTuple): data: List[int] try: typedload.load({'data': [1, 2, 'a']}, O) except Exception as e: for i in e.trace: print(i) Will print the entire trace: TraceItem(value={'data': [1, 2, 'a']}, type_=<class '__main__.O'>, annotation=None) TraceItem(value=[1, 2, 'a'], type_=typing.List[int], annotation=Annotation(annotation_type=<AnnotationType.FIELD: 'field'>, value='data')) TraceItem(value='a', type_=<class 'int'>, annotation=Annotation(annotation_type=<AnnotationType.INDEX: 'index'>, value=2)) And checking the annotation field it is possible to find out that the issue happened in data at index 2 .","title":"Trace"},{"location":"errors.html#union","text":"Because it is normal for a union of n types to generate n-1 exceptions, a union which fails generated n exceptions. Typedload has no way of knowing which of those is the important exception that was expected to succeed and instead puts all the exceptions inside the exception field of the parent exception. So all the sub exceptions can be investigated to decide which one is the most relevant one.","title":"Union"},{"location":"errors.html#raise-exceptions-in-custom-handlers","text":"To find the path where the wrong value was found, typedload needs to trace the execution by using annotations. This is used in handlers that do recursive calls to the loader. See the source code of the handlers for Union and NamedTuple to see how this is done.","title":"Raise exceptions in custom handlers"},{"location":"examples.html","text":"Examples Objects Three different kinds of objects are supported to be loaded and dumped back. NamedTuple (stdlib) dataclass (stdlib, since 3.7) attrs (3rd party module) More or less they all work in the same way: the object is defined, types are assigned for the fields and typedload can inspect the class and create an instance from a dictionary, or go the other way to a dictionary from an instance. from typing import NamedTuple, List from pathlib import Path import typedload from attr import attrs, attrib class File(NamedTuple): path: Union[str, Path] size: int @attrs class Directory: name = str files: List[File] = attrib(factory=list) # mutable objects require a factory, not a default value dir = { 'name': 'home', 'files': [ {'path': '/asd.txt', 'size': 0}, {'path': '/tmp/test.txt', 'size': 30}, ] } # Load the dictionary into objects d = typedload.load(dir, Directory) # Out: Directory(files=[File(path='/asd.txt', size=0), File(path='/tmp/test.txt', size=30)]) # Dump the objects into a dictionary typedload.dump(d) Please see the other sections for more advanced usage. Optional values Python typing is a bit confusing about Optional . An Optional[T] means that the field can assume None as value, but the value must still be specified, and can't be omitted. If, on the other hand, a variable has a default value, then when it's not explicitly specified, the default value is assumed. Typedload follows exactly the normal behaviour of python and mypy. import typedload from typing import Optional, NamedTuple class User(NamedTuple): username: str # Must be assigned nickname: Optional[str] # Must be assigned and can be None last_login: Optional[int] = None # Not required. # This fails, as nickname is not present typedload.load({'username': 'ltworf'}, User) # TypedloadValueError: Value does not contain fields: {'nickname'} which are necessary for type User # Those 2 work fine typedload.load({'username': 'ltworf', 'nickname': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': 'LtWorf'}, User) # Out: User(username='ltworf', nickname='LtWorf', last_login=None) # Those 2 work fine too typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': 666}, User) # Out: User(username='ltworf', nickname=None, last_login=666) There is of course no relationship between a default value and Optional , so a default can be anything. class Coordinates(NamedTuple): x: int = 0 y: int = 0 When dumping values, the fields which match with their default value are omitted. # Returns an empty dictionary typedload.dump(Coordinates()) # Out: {} # Returns only the x value typedload.dump(Coordinates(x=42, y=0)) # Out: {'x': 42} # Returns both coordinates typedload.dump(Coordinates(), hidedefault=False) # Out: {'x': 0, 'y': 0} Unions Disable cast Many times it is beneficial to disable casting when loading. For example, if a value can be an object of a certain kind or a string, not disabling casting will cast any invalid object to a string, which might not be desired. import typedload from typing import NamedTuple, Union class Data(NamedTuple): data: int # This loads \"{'date': 33}\", since the object is not a valid Data object. typedload.load({'date': 33}, Union[str, Data]) # Out: \"{'date': 33}\" # This fails, because the dictionary is not cast to str typedload.load({'date': 33}, Union[str, Data], basiccast=False) # TypedloadValueError: Value of dict could not be loaded into typing.Union[str, __main__.Data] List or single object Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_points # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points # Out: [Point(x=1.4, y=4.1), Point(x=5.2, y=6.13)] typedload.load(data1, Data).data_points # Out: [Point(x=1.4, y=4.1)] typedload.load(data2, Data).data_points # Out: [] Objects Loading different objects with a Union is of course possible, but some care is needed to avoid unexpected results. For example, using objects with default values is a bad idea: import typedload from typing import NamedTuple, Union, Optional class Person(NamedTuple): name: str = '' class Data(NamedTuple): data: Optional[str] = None # WARNING: This might return either a Person or a Data. It's random typedload.load({}, Union[Person, Data]) # Out: Data(data=None) # Out: Person(name='') This happens because in the union the order of the type is random, and either object works fine. So you want to use union on objects that have at least one non default non colliding field. You might want to use failonextra for objects whose fields are subset of other objects. import typedload from typing import NamedTuple, Union class Person(NamedTuple): name: str class Car(NamedTuple): name: str model: str # This should be a Car, not a Person data = {'name': 'macchina', 'model': 'TP21'} # WARNING: This can return either a Person or a Car typedload.load(data, Union[Person, Car]) # Out: Person(name='macchina') # Out: Car(name='macchina', model='TP21') # This can be explained by checking that both of these work typedload.load(data, Person) # Out: Person(name='macchina') typedload.load(data, Car) # Out: Car(name='macchina', model='TP21') # The data we have works for both objects, and the union # picks the first one (python sorts them randomly) # We want to avoid that dictionary to be loaded as Person, so we use failonextra # This fails typedload.load(data, Person, failonextra=True) # TypedloadValueError: Dictionary has unrecognized fields: model and cannot be loaded into Person # This works typedload.load(data, Car, failonextra=True) # Out: Car(name='macchina', model='TP21') # At this point the union will reliably pick the class that we want typedload.load(data, Union[Person, Car], failonextra=True) # Out: Car(name='macchina', model='TP21') Object type in value Let's assume that our json objects contain a type field that names the object itself. This makes conflicts impossible and so in the union the correct type will always be picked. This is very fast, because typedload will internally use the Literal values to try the best type in the union first. Slack sends events in this way. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) # Out: [Message(type='message', text='hello'), UserJoined(type='user-joined', username='giuf\u00e0')] Name mangling Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') When dumping back the data typedload.dump(character) # Out: {'lastName': 'Paperino', 'firstName': 'Paolino'} the names will be converted back to camel case. Multiple name mangling schemes If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') typedload.dump(character, mangle_key='alt_name') # Out: {'last-name': 'Paperino', 'first-name': 'Paolino'} Load and dump types from str Some classes are easy to load and dump from str . For example this is done for Path . Let's assume we want to have a class that is called SerialNumber that we load from a string and dump back to a string. Here's how it can be done: from typing import List import typedload.datadumper import typedload.dataloader class SerialNumber: def __init__(self, sn: str) -> None: # Some validation if ' ' in sn: raise Exception('Invalid serial number') self.sn = sn def __str__(self): return self.sn l = typedload.dataloader.Loader() d = typedload.datadumper.Dumper() l.strconstructed.add(SerialNumber) d.strconstructed.add(SerialNumber) serials = l.load(['1', '2', '3'], List[SerialNumber]) d.dump(serials) Custom handlers Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda dumper, value, value_type: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something.","title":"Examples"},{"location":"examples.html#examples","text":"","title":"Examples"},{"location":"examples.html#objects","text":"Three different kinds of objects are supported to be loaded and dumped back. NamedTuple (stdlib) dataclass (stdlib, since 3.7) attrs (3rd party module) More or less they all work in the same way: the object is defined, types are assigned for the fields and typedload can inspect the class and create an instance from a dictionary, or go the other way to a dictionary from an instance. from typing import NamedTuple, List from pathlib import Path import typedload from attr import attrs, attrib class File(NamedTuple): path: Union[str, Path] size: int @attrs class Directory: name = str files: List[File] = attrib(factory=list) # mutable objects require a factory, not a default value dir = { 'name': 'home', 'files': [ {'path': '/asd.txt', 'size': 0}, {'path': '/tmp/test.txt', 'size': 30}, ] } # Load the dictionary into objects d = typedload.load(dir, Directory) # Out: Directory(files=[File(path='/asd.txt', size=0), File(path='/tmp/test.txt', size=30)]) # Dump the objects into a dictionary typedload.dump(d) Please see the other sections for more advanced usage.","title":"Objects"},{"location":"examples.html#optional-values","text":"Python typing is a bit confusing about Optional . An Optional[T] means that the field can assume None as value, but the value must still be specified, and can't be omitted. If, on the other hand, a variable has a default value, then when it's not explicitly specified, the default value is assumed. Typedload follows exactly the normal behaviour of python and mypy. import typedload from typing import Optional, NamedTuple class User(NamedTuple): username: str # Must be assigned nickname: Optional[str] # Must be assigned and can be None last_login: Optional[int] = None # Not required. # This fails, as nickname is not present typedload.load({'username': 'ltworf'}, User) # TypedloadValueError: Value does not contain fields: {'nickname'} which are necessary for type User # Those 2 work fine typedload.load({'username': 'ltworf', 'nickname': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': 'LtWorf'}, User) # Out: User(username='ltworf', nickname='LtWorf', last_login=None) # Those 2 work fine too typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': None}, User) # Out: User(username='ltworf', nickname=None, last_login=None) typedload.load({'username': 'ltworf', 'nickname': None, 'last_login': 666}, User) # Out: User(username='ltworf', nickname=None, last_login=666) There is of course no relationship between a default value and Optional , so a default can be anything. class Coordinates(NamedTuple): x: int = 0 y: int = 0 When dumping values, the fields which match with their default value are omitted. # Returns an empty dictionary typedload.dump(Coordinates()) # Out: {} # Returns only the x value typedload.dump(Coordinates(x=42, y=0)) # Out: {'x': 42} # Returns both coordinates typedload.dump(Coordinates(), hidedefault=False) # Out: {'x': 0, 'y': 0}","title":"Optional values"},{"location":"examples.html#unions","text":"","title":"Unions"},{"location":"examples.html#disable-cast","text":"Many times it is beneficial to disable casting when loading. For example, if a value can be an object of a certain kind or a string, not disabling casting will cast any invalid object to a string, which might not be desired. import typedload from typing import NamedTuple, Union class Data(NamedTuple): data: int # This loads \"{'date': 33}\", since the object is not a valid Data object. typedload.load({'date': 33}, Union[str, Data]) # Out: \"{'date': 33}\" # This fails, because the dictionary is not cast to str typedload.load({'date': 33}, Union[str, Data], basiccast=False) # TypedloadValueError: Value of dict could not be loaded into typing.Union[str, __main__.Data]","title":"Disable cast"},{"location":"examples.html#list-or-single-object","text":"Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_points # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points # Out: [Point(x=1.4, y=4.1), Point(x=5.2, y=6.13)] typedload.load(data1, Data).data_points # Out: [Point(x=1.4, y=4.1)] typedload.load(data2, Data).data_points # Out: []","title":"List or single object"},{"location":"examples.html#objects_1","text":"Loading different objects with a Union is of course possible, but some care is needed to avoid unexpected results. For example, using objects with default values is a bad idea: import typedload from typing import NamedTuple, Union, Optional class Person(NamedTuple): name: str = '' class Data(NamedTuple): data: Optional[str] = None # WARNING: This might return either a Person or a Data. It's random typedload.load({}, Union[Person, Data]) # Out: Data(data=None) # Out: Person(name='') This happens because in the union the order of the type is random, and either object works fine. So you want to use union on objects that have at least one non default non colliding field. You might want to use failonextra for objects whose fields are subset of other objects. import typedload from typing import NamedTuple, Union class Person(NamedTuple): name: str class Car(NamedTuple): name: str model: str # This should be a Car, not a Person data = {'name': 'macchina', 'model': 'TP21'} # WARNING: This can return either a Person or a Car typedload.load(data, Union[Person, Car]) # Out: Person(name='macchina') # Out: Car(name='macchina', model='TP21') # This can be explained by checking that both of these work typedload.load(data, Person) # Out: Person(name='macchina') typedload.load(data, Car) # Out: Car(name='macchina', model='TP21') # The data we have works for both objects, and the union # picks the first one (python sorts them randomly) # We want to avoid that dictionary to be loaded as Person, so we use failonextra # This fails typedload.load(data, Person, failonextra=True) # TypedloadValueError: Dictionary has unrecognized fields: model and cannot be loaded into Person # This works typedload.load(data, Car, failonextra=True) # Out: Car(name='macchina', model='TP21') # At this point the union will reliably pick the class that we want typedload.load(data, Union[Person, Car], failonextra=True) # Out: Car(name='macchina', model='TP21')","title":"Objects"},{"location":"examples.html#object-type-in-value","text":"Let's assume that our json objects contain a type field that names the object itself. This makes conflicts impossible and so in the union the correct type will always be picked. This is very fast, because typedload will internally use the Literal values to try the best type in the union first. Slack sends events in this way. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) # Out: [Message(type='message', text='hello'), UserJoined(type='user-joined', username='giuf\u00e0')]","title":"Object type in value"},{"location":"examples.html#name-mangling","text":"Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') When dumping back the data typedload.dump(character) # Out: {'lastName': 'Paperino', 'firstName': 'Paolino'} the names will be converted back to camel case.","title":"Name mangling"},{"location":"examples.html#multiple-name-mangling-schemes","text":"If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) # Out: Character(first_name='Paolino', last_name='Paperino') typedload.dump(character, mangle_key='alt_name') # Out: {'last-name': 'Paperino', 'first-name': 'Paolino'}","title":"Multiple name mangling schemes"},{"location":"examples.html#load-and-dump-types-from-str","text":"Some classes are easy to load and dump from str . For example this is done for Path . Let's assume we want to have a class that is called SerialNumber that we load from a string and dump back to a string. Here's how it can be done: from typing import List import typedload.datadumper import typedload.dataloader class SerialNumber: def __init__(self, sn: str) -> None: # Some validation if ' ' in sn: raise Exception('Invalid serial number') self.sn = sn def __str__(self): return self.sn l = typedload.dataloader.Loader() d = typedload.datadumper.Dumper() l.strconstructed.add(SerialNumber) d.strconstructed.add(SerialNumber) serials = l.load(['1', '2', '3'], List[SerialNumber]) d.dump(serials)","title":"Load and dump types from str"},{"location":"examples.html#custom-handlers","text":"Let's assume that our codebase uses methods from_json() and to_json() as custom methods, and we want to use those. from typing import NamedTuple import typedload.datadumper import typedload.dataloader import typedload.exceptions # This is a NamedTuple, but we want to give priority to the from/to json methods class Point(NamedTuple): x: int y: int @staticmethod def from_json(data): # Checks on the data # Typedload handlers must raise subclasses of TypedloadException to work properly if not isinstance(data, list): raise typedload.exceptions.TypedloadTypeError('List expected') if len(data) != 2: raise typedload.exceptions.TypedloadTypeError('Only 2 items') if not all(isinstance(i, int) for i in data): raise typedload.exceptions.TypedloadValueError('Values must be int') # Return the data return Point(*data) def to_json(self): return [self.x, self.y] # We get a loader l = typedload.dataloader.Loader() # We find which handler handles NamedTuple nt_handler = l.index(Point) # We prepare a new handler load_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda loader, value, type_: type_.from_json(value) # Call the from_json and return its value ) # We add the new handler l.handlers.insert(nt_handler, load_handler) # Ready to try it! l.load([1, 2], Point) # Out: Point(x=1, y=2) # Now we do the dumper d = typedload.datadumper.Dumper() nt_handler = d.index(Point(1,2)) # We need to use a real object to find the handler dump_handler = ( lambda x: hasattr(x, 'from_json'), # Anything that has a from_json lambda dumper, value, value_type: value.to_json() # Call the from_json and return its value ) d.handlers.insert(nt_handler, dump_handler) d.dump(Point(5, 5)) # Out: [5, 5] Handlers basically permit doing anything, replacing current handlers or adding more to deal with more types. You can just append them to the list if you are extending. Remember to always use typedload exceptions, implement checks, and never modify the handler list after loading or dumping something.","title":"Custom handlers"},{"location":"origin_story.html","text":"typedload's origin story At $DAYJOB there was a software written in Scala, that worked by mapping objects into mongodb data. The only one person there knowing Scala decided to quit, and so we were in the process of rewriting the entire thing in Python. I had been tasked to write a few hundreds methods to_json() and from_json() for all the various objects that are used by this software. Since I thought it was going to be a terribly boring job in which I'd make tens of typos, I looked for a library that did such a thing. But of course none existed, so I started writing a module to do that. The to_json() part was rather easy, while the opposite wasn't, anyway after a few days the module seemed to be working nice. The module in fact worked so nicely that I wanted to use it in my personal projects as well. However I couldn't, as I had written it at $DAYJOB and I knew that getting the authorization to release it as open source would take from 2 years to +\u221e. So, I just wrote a stand alone library outside of work to do the exact same thing, but in a more generic and flexible way, rather than tied to the specific software we had at $DAYJOB. The result of writing the same library twice was that the second time around it came out better, and so the original version got completely discarded and at $DAYJOB typedload is now in use. At the time pydantic existed but it was not available on any distribution and was not production quality.","title":"Origin story"},{"location":"origin_story.html#typedloads-origin-story","text":"At $DAYJOB there was a software written in Scala, that worked by mapping objects into mongodb data. The only one person there knowing Scala decided to quit, and so we were in the process of rewriting the entire thing in Python. I had been tasked to write a few hundreds methods to_json() and from_json() for all the various objects that are used by this software. Since I thought it was going to be a terribly boring job in which I'd make tens of typos, I looked for a library that did such a thing. But of course none existed, so I started writing a module to do that. The to_json() part was rather easy, while the opposite wasn't, anyway after a few days the module seemed to be working nice. The module in fact worked so nicely that I wanted to use it in my personal projects as well. However I couldn't, as I had written it at $DAYJOB and I knew that getting the authorization to release it as open source would take from 2 years to +\u221e. So, I just wrote a stand alone library outside of work to do the exact same thing, but in a more generic and flexible way, rather than tied to the specific software we had at $DAYJOB. The result of writing the same library twice was that the second time around it came out better, and so the original version got completely discarded and at $DAYJOB typedload is now in use. At the time pydantic existed but it was not available on any distribution and was not production quality.","title":"typedload's origin story"},{"location":"performance.html","text":"Performance The tests are done on my PC. typedload manages to win quite a few benchmarks despite the competitors are compiled to binary .so files. Probably compiling it would make it win hands down. Feel free to help! Negative values mean that the library could not do the test or returned incorrect values. typedload pydantic is always slower apischema is slower for nested data and faster otherwise Using Python 3.11 Using Pypy 7.3.12 Run the tests Generate the performance chart locally. python3 -m venv perfvenv . perfvenv/bin/activate pip install apischema pydantic attrs export PYTHONPATH=$(pwd) make gnuplot","title":"Performance"},{"location":"performance.html#performance","text":"The tests are done on my PC. typedload manages to win quite a few benchmarks despite the competitors are compiled to binary .so files. Probably compiling it would make it win hands down. Feel free to help! Negative values mean that the library could not do the test or returned incorrect values. typedload pydantic is always slower apischema is slower for nested data and faster otherwise","title":"Performance"},{"location":"performance.html#using-python-311","text":"","title":"Using Python 3.11"},{"location":"performance.html#using-pypy-7312","text":"","title":"Using Pypy 7.3.12"},{"location":"performance.html#run-the-tests","text":"Generate the performance chart locally. python3 -m venv perfvenv . perfvenv/bin/activate pip install apischema pydantic attrs export PYTHONPATH=$(pwd) make gnuplot","title":"Run the tests"},{"location":"supported_types.html","text":"Supported types None typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself. Basic types By default: {int, bool, float, str, NONETYPE} Those types are the basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1 typing.Literal typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union . It is very common to use Literal to disambiguate objects in a Union. See example This is very fast, because typedload will internally use the Literal values to try the best type in the union first. enum.Enum class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used. typing.List In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list. typing.Tuple Always dumped as a list. Finite size tuple In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError Infinite size tuple In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size. typing.Dict In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct. Objects typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr.ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) total: int = field(init=False) def __post_init__(self): self.total = 123 # calculation here In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)], total=123) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped. attrs converters Attrs fields can have a converter function associated. If this is the case, typedload will ignore the assigned type, inspect the type hints of the converter function, and assign the type of the parameter of the converter as type. If the function is not typed, Any will be used. This can be useful when the data format has been changed in a more complex way than just adding a few extra fields. Then the converter function can be used to do the necessary conversions for the old data format. Examples @attr.s class A: x: int = attr.ib(converter=str) # x has a converter that just calls str() In : load({'x': [1]}, A) Out: A(x='[1]') # In this case the int type for x was completely ignored, because a converter is defined # The str() function does not define type hints, so Any is used # So the list [1] is passed as is to the constructor of A() which calls str() on it to convert it @attr.s class Old: oldfield: int = attr.ib() @attr.s class New: newfield: int = attr.ib() def conv(p: Old | New) -> New: # The type hinting necessary to tell typedload what to do # Without hinting it would just pass the dictionary directly if isinstance(p, New): return p return New(p.oldfield) @attr.s class Outer: ''' Our old data format was using the Old class, but we now use the New class. The converter returns a New instance from an Old instance. ''' inner: New = attr.ib(converter=conv) # Calling load with the new data format, returns a New class In : load({'inner': {'newfield':3}}, Outer) Out: Outer(inner=New(newfield=3)) # Loading with the old data format, still returns a New class In : load({'inner': {'oldfield':3}}, Outer) Out: Outer(inner=New(newfield=3)) Forward references A forward reference is when a type is specified as a string instead of as an object: a: ObjA = ObjA() a: 'ObjA' = ObjA() The 2nd generates a forward reference, that is, a fake type that is really hard to resolve. The current strategy for typedload is to cache all the names of the types it encounters and use this cache to resolve the names. In alternative, it is possible to use the frefs dictionary to manually force resolution for a particular type. Python typing module offers some ways to resolve those types which are not used at the moment because they are slow and have strong limitations. Python developers want to turn every type annotation into a forward reference, for speed reasons. This was supposed to come in 3.10 but has been postponed. So for the moment there is little point into working on this very volatile API. typing.Union A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime. Optional A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None Ambiguity Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1) Finding ambiguity Typedload can't solve certain ambiguities, but setting uniondebugconflict=True will help detect them. In : typedload.load({}, Union[A, B], uniondebugconflict=True) TypedloadTypeError: Value of dict could be loaded into typing.Union[__main__.A, __main__.B] multiple times So this setting can be used to find ambiguities and manually correct them. NOTE : The setting slows down the loading of unions, so it is recommended to use it only during tests or when designing the data structures, but not in production. typing.TypedDict class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected. It also supports non-total TypedDict (since 2.7). class A(TypedDict, total=False): val: str In : typedload.load({}, A) Out: {} NotRequired can also be used (since 2.17). class A(TypedDict): val: str vol: NotRequired[int] In : typedload.load({'val': 'a'}, A) Out: {'val': 'a'} typing.Set, typing.Frozenset In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list. typing.Any typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed. typing.NewType T = typing.NewType('T', str) typedload.load('ciao', T) Allows the use of NewType to define already handled types. String constructed Loaders and dumpers have a set of strconstructed . Those are types that accept a single str parameter in their constructor and have a __str__ method that returns that parameter. For those types, a specific handler is not needed and they can just be added to the strconstructed set. The preset ones are: pathlib.Path In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string. ipaddress.IPv*Address/Network/Interface ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string. argparse.Namespace This is converted to a dictionary and can be loaded into NamedTuple/dataclass. Dates datetime.timedelta Represented as a float of seconds. datetime.date datetime.time datetime.datetime When loading, it is possible to pass a string in ISO 8601, or a list of ints that will be passed to the constructor. When dumping, the default is to dump a list of ints, unless isodates=True is set in the dumper object, in which case an ISO 8601 string will be returned instead. The format with the list of ints is deprecated and kept for backward compatibility. Everybody should use the ISO 8601 strings. The format with the list of ints does not support timezones.","title":"Supported types"},{"location":"supported_types.html#supported-types","text":"","title":"Supported types"},{"location":"supported_types.html#none","text":"typedload.load(obj, None) It will either return a None or fail. This is normally used to handle unions such as Optional[int] rather than by itself.","title":"None"},{"location":"supported_types.html#basic-types","text":"By default: {int, bool, float, str, NONETYPE} Those types are the basic building blocks and no operations are performed on them. NOTE : If basiccast=True (the default) casting between them can still happen. In : typedload.load(1, float) Out: 1.0 In : typedload.load(1, str) Out: '1' In : typedload.load(1, int) Out: 1 In : typedload.load(1, float, basiccast=False) Exception: TypedloadValueError In : typedload.load(1, bool, basiccast=False) Exception: TypedloadValueError The basictypes set can be tweaked. In : typedload.load(1, bytes, basictypes={bytes, int}) Out: b'\\x00' In : typedload.load(1, int, basictypes={bytes, int}) Out: 1","title":"Basic types"},{"location":"supported_types.html#typingliteral","text":"typedload.load(obj, Literal[1]) typedload.load(obj, Literal[1,2,3]) Succeeds only if obj equals one of the allowed values. This is normally used in objects, to decide the correct type in a Union . It is very common to use Literal to disambiguate objects in a Union. See example This is very fast, because typedload will internally use the Literal values to try the best type in the union first.","title":"typing.Literal"},{"location":"supported_types.html#enumenum","text":"class Flags(Enum): NOVAL = 0 YESVAL = 1 In : typedload.load(1, Flags) Out: <Flags.YESVAL: 1> Load values from an Enum, when dumping the value is used.","title":"enum.Enum"},{"location":"supported_types.html#typinglist","text":"In : typedload.load([1, 2, 3], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int]) Out: [1, 2, 3] In : typedload.load([1.1, 2, '3'], List[int], basiccast=False) Exception: TypedloadValueError Load an iterable into a list object. Always dumped as a list.","title":"typing.List"},{"location":"supported_types.html#typingtuple","text":"Always dumped as a list.","title":"typing.Tuple"},{"location":"supported_types.html#finite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, float]) Out: (1, 2.0) # Be more strict and fail if there is more data than expected on the iterator In : typedload.load([1, 2, 3], Tuple[int, float], failonextra=True) Exception: TypedloadValueError","title":"Finite size tuple"},{"location":"supported_types.html#infinite-size-tuple","text":"In : typedload.load([1, 2, 3], Tuple[int, ...]) Out: (1, 2, 3) Uses Ellipsis ( ... ) to indicate that the tuple contains an indefinite amount of items of the same size.","title":"Infinite size tuple"},{"location":"supported_types.html#typingdict","text":"In : typedload.load({1: '1'}, Dict[int, Path]) Out: {1: PosixPath('1')} In : typedload.load({1: '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str]) Out: {1: '1'} In : typedload.load({'1': '1'}, Dict[int, str], basiccast=False) Exception: TypedloadValueError class A(NamedTuple): y: str='a' In : typedload.load({1: {}}, Dict[int, A], basiccast=False) Out: {1: A(y='2')} Loads a dictionary, making sure that the types are correct.","title":"typing.Dict"},{"location":"supported_types.html#objects","text":"typing.NamedTuple dataclasses.dataclass attr.s class Point2d(NamedTuple): x: float y: float class Point3d(NamedTuple): x: float y: float z: float @attr.s class Polygon: vertex: List[Point2d] = attr.ib(factory=list, metadata={'name': 'Vertex'}) @dataclass class Solid: vertex: List[Point3d] = field(default_factory=list) total: int = field(init=False) def __post_init__(self): self.total = 123 # calculation here In : typedload.load({'Vertex':[{'x': 1,'y': 1}, {'x': 2,'y': 2},{'x': 3,'y': 3}]}, Polygon) Out: Polygon(vertex=[Point2d(x=1.0, y=1.0), Point2d(x=2.0, y=2.0), Point2d(x=3.0, y=3.0)]) In : typedload.load({'vertex':[{'x': 1,'y': 1,'z': 1}, {'x': 2,'y': 2, 'z': 2},{'x': 3,'y': 3,'z': 3}]}, Solid) Out: Solid(vertex=[Point3d(x=1.0, y=1.0, z=1.0), Point3d(x=2.0, y=2.0, z=2.0), Point3d(x=3.0, y=3.0, z=3.0)], total=123) They are loaded from dictionaries into those objects. failonextra when set can generate exceptions if more fields than expected are present. When dumping they go back to dictionaries. hide_default defaults to True, so all fields that were equal to the default will not be dumped.","title":"Objects"},{"location":"supported_types.html#attrs-converters","text":"Attrs fields can have a converter function associated. If this is the case, typedload will ignore the assigned type, inspect the type hints of the converter function, and assign the type of the parameter of the converter as type. If the function is not typed, Any will be used. This can be useful when the data format has been changed in a more complex way than just adding a few extra fields. Then the converter function can be used to do the necessary conversions for the old data format.","title":"attrs converters"},{"location":"supported_types.html#examples","text":"@attr.s class A: x: int = attr.ib(converter=str) # x has a converter that just calls str() In : load({'x': [1]}, A) Out: A(x='[1]') # In this case the int type for x was completely ignored, because a converter is defined # The str() function does not define type hints, so Any is used # So the list [1] is passed as is to the constructor of A() which calls str() on it to convert it @attr.s class Old: oldfield: int = attr.ib() @attr.s class New: newfield: int = attr.ib() def conv(p: Old | New) -> New: # The type hinting necessary to tell typedload what to do # Without hinting it would just pass the dictionary directly if isinstance(p, New): return p return New(p.oldfield) @attr.s class Outer: ''' Our old data format was using the Old class, but we now use the New class. The converter returns a New instance from an Old instance. ''' inner: New = attr.ib(converter=conv) # Calling load with the new data format, returns a New class In : load({'inner': {'newfield':3}}, Outer) Out: Outer(inner=New(newfield=3)) # Loading with the old data format, still returns a New class In : load({'inner': {'oldfield':3}}, Outer) Out: Outer(inner=New(newfield=3))","title":"Examples"},{"location":"supported_types.html#forward-references","text":"A forward reference is when a type is specified as a string instead of as an object: a: ObjA = ObjA() a: 'ObjA' = ObjA() The 2nd generates a forward reference, that is, a fake type that is really hard to resolve. The current strategy for typedload is to cache all the names of the types it encounters and use this cache to resolve the names. In alternative, it is possible to use the frefs dictionary to manually force resolution for a particular type. Python typing module offers some ways to resolve those types which are not used at the moment because they are slow and have strong limitations. Python developers want to turn every type annotation into a forward reference, for speed reasons. This was supposed to come in 3.10 but has been postponed. So for the moment there is little point into working on this very volatile API.","title":"Forward references"},{"location":"supported_types.html#typingunion","text":"A union means that a value can be of more than one type. If the passed value is of a basictype that is also present in the Union, the value will be returned. Otherwise, basictype values are evaluated last. This is to avoid that a Union containing a str will catch more than it should. After this sorting of types, a Union is loaded by trying to load the value with each of the types. The first load that succeeds is returned. In general you cannot make assumptions on the order in which types are evaluated, because it is decided by the runtime.","title":"typing.Union"},{"location":"supported_types.html#optional","text":"A typical case is when using Optional values In : typedload.load(3, Optional[int]) Out: 3 In : typedload.load(None, Optional[int]) Out: None","title":"Optional"},{"location":"supported_types.html#ambiguity","text":"Ambiguity can sometimes be fixed by enabling failonextra or disabling basiccast . Point2d = Tuple[float, float] Point3d = Tuple[float, float, float] # This is not what we wanted, the 3rd coordinate is lost In : typedload.load((1,1,1), Union[Point2d, Point3d]) Out: (1.0, 1.0) # Make the loading more strict! In : typedload.load((1,1,1), Union[Point2d, Point3d], failonextra=True) Out: (1.0, 1.0, 1.0) But in some cases it cannot be simply solved, when the types in the Union are too similar. In this case the only solution is to rework the codebase. # A casting must be done, str was chosen, but could have been int In : typedload.load(1.1, Union[str, int]) Out: '1.1' class A(NamedTuple): x: int=1 class B(NamedTuple): y: str='a' # Both A and B accept an empty constructor In : typedload.load({}, Union[A, B]) Out: A(x=1)","title":"Ambiguity"},{"location":"supported_types.html#finding-ambiguity","text":"Typedload can't solve certain ambiguities, but setting uniondebugconflict=True will help detect them. In : typedload.load({}, Union[A, B], uniondebugconflict=True) TypedloadTypeError: Value of dict could be loaded into typing.Union[__main__.A, __main__.B] multiple times So this setting can be used to find ambiguities and manually correct them. NOTE : The setting slows down the loading of unions, so it is recommended to use it only during tests or when designing the data structures, but not in production.","title":"Finding ambiguity"},{"location":"supported_types.html#typingtypeddict","text":"class A(TypedDict): val: str In : typedload.load({'val': 3}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A) Out: {'val': '3'} In : typedload.load({'val': 3,'aaa':2}, A, failonextra=True) Exception: TypedloadValueError From dict to dict, but it makes sure that the types are as expected. It also supports non-total TypedDict (since 2.7). class A(TypedDict, total=False): val: str In : typedload.load({}, A) Out: {} NotRequired can also be used (since 2.17). class A(TypedDict): val: str vol: NotRequired[int] In : typedload.load({'val': 'a'}, A) Out: {'val': 'a'}","title":"typing.TypedDict"},{"location":"supported_types.html#typingset-typingfrozenset","text":"In : typedload.load([1, 4, 99], set[float]) Out: {1.0, 4.0, 99.0} In : typedload.load(range(12), Set[int]) Out: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} In : typedload.load(range(12), frozenset[float]) Out: frozenset({0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0}) Loads an iterable inside a set or a frozenset . Always dumped as a list.","title":"typing.Set, typing.Frozenset"},{"location":"supported_types.html#typingany","text":"typedload.load(obj, typing.Any) This will just return obj without doing any check or transformation. To work with dump() , obj needs to be of a supported type, or an handler is needed.","title":"typing.Any"},{"location":"supported_types.html#typingnewtype","text":"T = typing.NewType('T', str) typedload.load('ciao', T) Allows the use of NewType to define already handled types.","title":"typing.NewType"},{"location":"supported_types.html#string-constructed","text":"Loaders and dumpers have a set of strconstructed . Those are types that accept a single str parameter in their constructor and have a __str__ method that returns that parameter. For those types, a specific handler is not needed and they can just be added to the strconstructed set. The preset ones are:","title":"String constructed"},{"location":"supported_types.html#pathlibpath","text":"In : typedload.load('/tmp/', Path) Out: PosixPath('/tmp') In : typedload.load('/tmp/file.txt', Path) Out: PosixPath('/tmp/file.txt') Loads a string as a Path ; when dumping it goes back to being a string.","title":"pathlib.Path"},{"location":"supported_types.html#ipaddressipvaddressnetworkinterface","text":"ipaddress.IPv4Address ipaddress.IPv6Address ipaddress.IPv4Network ipaddress.IPv6Network ipaddress.IPv4Interface ipaddress.IPv6Interface In : typedload.load('10.1.1.3', IPv4Address) Out: IPv4Address('10.1.1.3') Loads a string as an one of those classes, and dumps back to string.","title":"ipaddress.IPv*Address/Network/Interface"},{"location":"supported_types.html#argparsenamespace","text":"This is converted to a dictionary and can be loaded into NamedTuple/dataclass.","title":"argparse.Namespace"},{"location":"supported_types.html#dates","text":"","title":"Dates"},{"location":"supported_types.html#datetimetimedelta","text":"Represented as a float of seconds.","title":"datetime.timedelta"},{"location":"supported_types.html#datetimedate-datetimetime-datetimedatetime","text":"When loading, it is possible to pass a string in ISO 8601, or a list of ints that will be passed to the constructor. When dumping, the default is to dump a list of ints, unless isodates=True is set in the dumper object, in which case an ISO 8601 string will be returned instead. The format with the list of ints is deprecated and kept for backward compatibility. Everybody should use the ISO 8601 strings. The format with the list of ints does not support timezones.","title":"datetime.date datetime.time datetime.datetime"},{"location":"typedload.datadumper_docgen.html","text":"typedload This module is the inverse of dataloader. It converts typed data structures to things that json can serialize. Classes Dumper This dumps data structures recursively using only basic types, lists and dictionaries. A value dumped in this way from a typed data structure can be loaded back using dataloader. hidedefault: Enabled by default. When enabled, does not include fields that have the same value as the default in the dump. isodates: Disabled by default. Will be enabled by default from version 3. When disabled, datetime.datetime, datetime.time, datetime.date are dumped as lists of ints. When enabled they are dumped as strings in ISO 8601 format. When enabled, timezone information will work. raiseconditionerrors: Enabled by default. Raises exceptions when evaluating a condition from an handler. When disabled, the exceptions are not raised and the condition is considered False. mangle_key: Defaults to 'name' Specifies which key is used into the metadata dictionaries to perform name-mangling. handlers: This is the list that the dumper uses to perform its task. The type is: List[ Tuple[ Callable[[Any], bool], Callable[['Dumper', Any, Any], Any] ] ] The elements are: Tuple[Condition, Dumper] Condition(value) -> Bool Dumper(dumper, value, value_type) -> simpler_value In most cases, it is sufficient to append new elements at the end, to handle more types. strconstructed: Set of types to dump to a string. These parameters can be set as named arguments in the constructor or they can be set later on. The constructor will accept any named argument, but only the documented ones have any effect. This is to allow custom handlers to have their own parameters as well. Because internal caches are used, after the first call to dump() these properties should no longer be modified. There is support for: * Basic python types (int, str, bool, float, NoneType) * NamedTuple, dataclasses, attrs, TypedDict * Dict[TypeA, TypeB] * Enum * List * Tuple * Set * FrozenSet * Path * IPv4Address, IPv6Address, IPv4Network, IPv6Network, IPv4Interface, IPv6Interface * datetime","title":"typedload.datadumper"},{"location":"typedload.datadumper_docgen.html#classes","text":"","title":"Classes"},{"location":"typedload.datadumper_docgen.html#dumper","text":"This dumps data structures recursively using only basic types, lists and dictionaries. A value dumped in this way from a typed data structure can be loaded back using dataloader. hidedefault: Enabled by default. When enabled, does not include fields that have the same value as the default in the dump. isodates: Disabled by default. Will be enabled by default from version 3. When disabled, datetime.datetime, datetime.time, datetime.date are dumped as lists of ints. When enabled they are dumped as strings in ISO 8601 format. When enabled, timezone information will work. raiseconditionerrors: Enabled by default. Raises exceptions when evaluating a condition from an handler. When disabled, the exceptions are not raised and the condition is considered False. mangle_key: Defaults to 'name' Specifies which key is used into the metadata dictionaries to perform name-mangling. handlers: This is the list that the dumper uses to perform its task. The type is: List[ Tuple[ Callable[[Any], bool], Callable[['Dumper', Any, Any], Any] ] ] The elements are: Tuple[Condition, Dumper] Condition(value) -> Bool Dumper(dumper, value, value_type) -> simpler_value In most cases, it is sufficient to append new elements at the end, to handle more types. strconstructed: Set of types to dump to a string. These parameters can be set as named arguments in the constructor or they can be set later on. The constructor will accept any named argument, but only the documented ones have any effect. This is to allow custom handlers to have their own parameters as well. Because internal caches are used, after the first call to dump() these properties should no longer be modified. There is support for: * Basic python types (int, str, bool, float, NoneType) * NamedTuple, dataclasses, attrs, TypedDict * Dict[TypeA, TypeB] * Enum * List * Tuple * Set * FrozenSet * Path * IPv4Address, IPv6Address, IPv4Network, IPv6Network, IPv4Interface, IPv6Interface * datetime","title":"Dumper"},{"location":"typedload.dataloader_docgen.html","text":"typedload Module to load data into typed data structures Classes Loader A loader object that recursively loads data into the desired type. basictypes: a set of types that are considered as building blocks for everything else and do not need to be converted further. If you are not loading from json, you probably want to add bytes to the set. failonextra: Disabled by default. When enabled, the loader will raise exceptions if there are fields in the data that are not being used by the type. basiccast: Enabled by default. When disabled, instead of trying to perform casts, exceptions will be raised. Since many json seem to encode numbers as strings, to avoid extra complications this functionality is provided. If you know that your original data is encoded properly, it is better to disable this. dictequivalence: Enabled by default. Automatically convert dict-like classes to dictionary when loading. This enables them to be loaded into other classes. At the moment it supports: argparse.Namespace raiseconditionerrors: Enabled by default. Raises exceptions when evaluating a condition from an handler. When disabled, the exceptions are not raised and the condition is considered False. uniondebugconflict: Disabled by default When enabled, all the possible types for the unions are evaluated instead of stopping at the first that works. If more than one type in the union works, an error is raised because the types are conflicting and the union might return different types with the same input value. This option makes the loading slower and is only to be used when debugging issues. mangle_key: Defaults to 'name' Specifies which key is used into the metadata dictionaries to perform name-mangling. handlers: This is the list that the loader uses to perform its task. The type is: List[ Tuple[ Callable[[Type[T]], bool], Callable[['Loader', Any, Type[T]], T] ] ] The elements are: Tuple[Condition,Loader] Condition(type) -> Bool Loader(loader, value, type) -> type In most cases, it is sufficient to append new elements at the end, to handle more types. There is an internal cache to speed up lookup, so after the first call to load, this should no longer be modified. strconstructed: Set of types to construct from a string. frefs: Dictionary to resolve ForwardRef. Something like class Node(NamedTuple): next: Optional['Node'] requires a ForwardRef (also in python3.7), which means that the type is stored as string and must be resolved at runtime. This dictionary contains the names of the types as keys, and the actual types as values. A loader object by default starts with an empty dictionary and fills it with the types it encounters, but it is possible to manually add more types to the dictionary. Setting this to None disables any support for ForwardRef. Reusing the same loader object on unrelated types might cause failures, if the types are different but use the same names. pep563: Set to true to use __future__.annotations WARNING: DEPRECATED Support for this might be removed in any future release without notice. Check deferred evaluation in the documentation for more details. This will make typedload much slower. This PEP is broken and superseeded by PEP649. Do not report bugs about this \"feature\". It's not here to stay. These parameters can be set as named arguments in the constructor or they can be set later on. The constructor will accept any named argument, but only the documented ones have any effect. This is to allow custom handlers to have their own parameters as well. Because internal caches are used, after the first call to load() these properties should no longer be modified. Using unions is complicated. The best is to use tagged unions using a Literal field. If the types in the union are too similar to each other, it is easy to obtain an unexpected type.","title":"typedload.dataloader"},{"location":"typedload.dataloader_docgen.html#classes","text":"","title":"Classes"},{"location":"typedload.dataloader_docgen.html#loader","text":"A loader object that recursively loads data into the desired type. basictypes: a set of types that are considered as building blocks for everything else and do not need to be converted further. If you are not loading from json, you probably want to add bytes to the set. failonextra: Disabled by default. When enabled, the loader will raise exceptions if there are fields in the data that are not being used by the type. basiccast: Enabled by default. When disabled, instead of trying to perform casts, exceptions will be raised. Since many json seem to encode numbers as strings, to avoid extra complications this functionality is provided. If you know that your original data is encoded properly, it is better to disable this. dictequivalence: Enabled by default. Automatically convert dict-like classes to dictionary when loading. This enables them to be loaded into other classes. At the moment it supports: argparse.Namespace raiseconditionerrors: Enabled by default. Raises exceptions when evaluating a condition from an handler. When disabled, the exceptions are not raised and the condition is considered False. uniondebugconflict: Disabled by default When enabled, all the possible types for the unions are evaluated instead of stopping at the first that works. If more than one type in the union works, an error is raised because the types are conflicting and the union might return different types with the same input value. This option makes the loading slower and is only to be used when debugging issues. mangle_key: Defaults to 'name' Specifies which key is used into the metadata dictionaries to perform name-mangling. handlers: This is the list that the loader uses to perform its task. The type is: List[ Tuple[ Callable[[Type[T]], bool], Callable[['Loader', Any, Type[T]], T] ] ] The elements are: Tuple[Condition,Loader] Condition(type) -> Bool Loader(loader, value, type) -> type In most cases, it is sufficient to append new elements at the end, to handle more types. There is an internal cache to speed up lookup, so after the first call to load, this should no longer be modified. strconstructed: Set of types to construct from a string. frefs: Dictionary to resolve ForwardRef. Something like class Node(NamedTuple): next: Optional['Node'] requires a ForwardRef (also in python3.7), which means that the type is stored as string and must be resolved at runtime. This dictionary contains the names of the types as keys, and the actual types as values. A loader object by default starts with an empty dictionary and fills it with the types it encounters, but it is possible to manually add more types to the dictionary. Setting this to None disables any support for ForwardRef. Reusing the same loader object on unrelated types might cause failures, if the types are different but use the same names. pep563: Set to true to use __future__.annotations WARNING: DEPRECATED Support for this might be removed in any future release without notice. Check deferred evaluation in the documentation for more details. This will make typedload much slower. This PEP is broken and superseeded by PEP649. Do not report bugs about this \"feature\". It's not here to stay. These parameters can be set as named arguments in the constructor or they can be set later on. The constructor will accept any named argument, but only the documented ones have any effect. This is to allow custom handlers to have their own parameters as well. Because internal caches are used, after the first call to load() these properties should no longer be modified. Using unions is complicated. The best is to use tagged unions using a Literal field. If the types in the union are too similar to each other, it is easy to obtain an unexpected type.","title":"Loader"},{"location":"typedload.exceptions_docgen.html","text":"typedload Exceptions Classes TypedloadException Exception which exposes some extra fields. trace: It is a list of all the recursive invocations of load(), with the parameters used. Very useful to locate the issue. The annotation is used by complex loaders that call load() more than once, to indicate in which step the error occurred. For example a list loader will use it to indicate the index which had the exception, and a NamedTuple loader will use it to indicate the name of the field which generated the exception. value: contains the value that could not be loaded. type_: contains the type in which the value could not be loaded. exceptions: A list of exceptions that happened during the loading. This is for now only used by the Union loader, to list all the exceptions that occurred during the various attempts. TypedloadValueError Exception class, subclass of ValueError. See the documentation of TypedloadException for more details. TypedloadTypeError Exception class, subclass of TypeError. See the documentation of TypedloadException for more details. TypedloadAttributeError Exception class, subclass of AttributeError. See the documentation of TypedloadException for more details. Annotation Annotation(annotation_type, value) TraceItem TraceItem(value, type_, annotation)","title":"typedload.exceptions"},{"location":"typedload.exceptions_docgen.html#classes","text":"","title":"Classes"},{"location":"typedload.exceptions_docgen.html#typedloadexception","text":"Exception which exposes some extra fields. trace: It is a list of all the recursive invocations of load(), with the parameters used. Very useful to locate the issue. The annotation is used by complex loaders that call load() more than once, to indicate in which step the error occurred. For example a list loader will use it to indicate the index which had the exception, and a NamedTuple loader will use it to indicate the name of the field which generated the exception. value: contains the value that could not be loaded. type_: contains the type in which the value could not be loaded. exceptions: A list of exceptions that happened during the loading. This is for now only used by the Union loader, to list all the exceptions that occurred during the various attempts.","title":"TypedloadException"},{"location":"typedload.exceptions_docgen.html#typedloadvalueerror","text":"Exception class, subclass of ValueError. See the documentation of TypedloadException for more details.","title":"TypedloadValueError"},{"location":"typedload.exceptions_docgen.html#typedloadtypeerror","text":"Exception class, subclass of TypeError. See the documentation of TypedloadException for more details.","title":"TypedloadTypeError"},{"location":"typedload.exceptions_docgen.html#typedloadattributeerror","text":"Exception class, subclass of AttributeError. See the documentation of TypedloadException for more details.","title":"TypedloadAttributeError"},{"location":"typedload.exceptions_docgen.html#annotation","text":"Annotation(annotation_type, value) TraceItem TraceItem(value, type_, annotation)","title":"Annotation"},{"location":"typedload.typechecks_docgen.html","text":"typedload Module to check types, mostly from the typing module. For example is_list(List) and is_list(List[int]) return True. It is not the same as isinstance(), it wants types, not instances. It is expected that is_list(list) returns False, since it shouldn't be used for type hints. The module is useful because there is no public API to do those checks, and it protects the user from the ever changing internal representation used in different versions of Python. Functions is_any Check if it is a typing.Any is_attrs Check if the type is obtained with an @attr.s decorator is_dataclass dataclass (Introduced in Python3.7 is_dict Dict[A, B] Dict is_enum Check if the class is a subclass of Enum is_forwardref Check if it's a ForwardRef. They are unresolved types passed as strings, supposed to be resolved into types at a later moment is_frozenset FrozenSet[A] FrozenSet is_list List[A] List is_literal Check if the type is a typing.Literal is_namedtuple Generated with typing.NamedTuple is_nonetype type_ == type(None) is_set Set[A] Set is_tuple Tuple[int, str] Tuple is_union Union[A, B] Union Optional[A] A | B is_typeddict Check if it is a typing.TypedDict is_optional Optional[int] int | None Note that Optional is just a Union, so if is_optional is True then also is_union will be True is_notrequired Check if it's typing.NotRequired or typing_extensions.NotRequired notrequiredtype Return the type wrapped by NotRequired uniontypes Returns the types of a Union. literalvalues Returns the values of a Literal Raises ValueError if the argument is not a Literal Classes","title":"typedload.typechecks"},{"location":"typedload.typechecks_docgen.html#functions","text":"","title":"Functions"},{"location":"typedload.typechecks_docgen.html#is_any","text":"Check if it is a typing.Any","title":"is_any"},{"location":"typedload.typechecks_docgen.html#is_attrs","text":"Check if the type is obtained with an @attr.s decorator","title":"is_attrs"},{"location":"typedload.typechecks_docgen.html#is_dataclass","text":"dataclass (Introduced in Python3.7","title":"is_dataclass"},{"location":"typedload.typechecks_docgen.html#is_dict","text":"Dict[A, B] Dict","title":"is_dict"},{"location":"typedload.typechecks_docgen.html#is_enum","text":"Check if the class is a subclass of Enum","title":"is_enum"},{"location":"typedload.typechecks_docgen.html#is_forwardref","text":"Check if it's a ForwardRef. They are unresolved types passed as strings, supposed to be resolved into types at a later moment","title":"is_forwardref"},{"location":"typedload.typechecks_docgen.html#is_frozenset","text":"FrozenSet[A] FrozenSet","title":"is_frozenset"},{"location":"typedload.typechecks_docgen.html#is_list","text":"List[A] List","title":"is_list"},{"location":"typedload.typechecks_docgen.html#is_literal","text":"Check if the type is a typing.Literal","title":"is_literal"},{"location":"typedload.typechecks_docgen.html#is_namedtuple","text":"Generated with typing.NamedTuple","title":"is_namedtuple"},{"location":"typedload.typechecks_docgen.html#is_nonetype","text":"type_ == type(None)","title":"is_nonetype"},{"location":"typedload.typechecks_docgen.html#is_set","text":"Set[A] Set","title":"is_set"},{"location":"typedload.typechecks_docgen.html#is_tuple","text":"Tuple[int, str] Tuple","title":"is_tuple"},{"location":"typedload.typechecks_docgen.html#is_union","text":"Union[A, B] Union Optional[A] A | B","title":"is_union"},{"location":"typedload.typechecks_docgen.html#is_typeddict","text":"Check if it is a typing.TypedDict","title":"is_typeddict"},{"location":"typedload.typechecks_docgen.html#is_optional","text":"Optional[int] int | None Note that Optional is just a Union, so if is_optional is True then also is_union will be True","title":"is_optional"},{"location":"typedload.typechecks_docgen.html#is_notrequired","text":"Check if it's typing.NotRequired or typing_extensions.NotRequired","title":"is_notrequired"},{"location":"typedload.typechecks_docgen.html#notrequiredtype","text":"Return the type wrapped by NotRequired","title":"notrequiredtype"},{"location":"typedload.typechecks_docgen.html#uniontypes","text":"Returns the types of a Union.","title":"uniontypes"},{"location":"typedload.typechecks_docgen.html#literalvalues","text":"Returns the values of a Literal Raises ValueError if the argument is not a Literal","title":"literalvalues"},{"location":"typedload.typechecks_docgen.html#classes","text":"","title":"Classes"},{"location":"typedload_docgen.html","text":"typedload This library loads Python data structures into typed data structures, enforcing a schema. The main purpose is to load things that come from json, bson or similar into NamedTuple or Dataclass. For example this Json: { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this: class User(NamedTuple): username: str shell: str = 'bash' sessions: List[str] = [] class Logins(NamedTuple): users: List[User] And can then be loaded with typedload.load(data, Logins) Simple API typedload.load() and typedload.dump() are functions to quickly load and dump data using the default objects. They create a new loader/dumper object with default parameters, and discard it after. Classes The loader and dumper classes expose a number of attributes that can be customised to tweak their behaviour. Supported datatypes There is support for: * Basic python types (int, str, bool, float, NoneType) * NamedTuple * Enum * Optional[SomeType] * List[SomeType] * Dict[TypeA, TypeB] * Tuple[TypeA, TypeB, TypeC] * Tuple[SomeType, ...] * Set[SomeType] * Union[TypeA, TypeB] * ForwardRef * Literal * Dataclass * attrs * TypedDict * datetime * Path * IPv4Address, IPv6Address Handlers To work with other datatypes, handlers can be used. The handlers' list items are tuples for two functions. The signatures are different for loader or dumper. The first function returns a boolean, and if the value is true, the object will call the second function and return its result. Basically a loader and a dumper class have no functionality (but come with a default list of handlers). So, to add support for a new type, it is sufficient to write a function that outputs the desired value, and a function that decides when to call that. The index() function returns the position of handlers in the list, so that it is possible to remove them or add new handlers before or after a given handler. The pointer to the loader or dumper object is passed, so that the attributes in use for that particular object are available. For example, if we want to add a special loader that when loading the int 42 into a string returns 'quarantadue', we can do this: from typedload.dataloader import Loader l = Loader() l.handlers.insert( l.index(str), # This will place this entry before the string handler ( lambda x: x == str, lambda loader, value, type_: str(value) if value != 42 else 'quarantadue' ) ) Then this will happen: In [15]: l.load(12, str) Out[15]: '12' In [16]: l.load(42, str) Out[16]: 'quarantadue' This can of course be used also for use cases that make sense. The handlers must generate exceptions from the typedload.exceptions module. Due to internal cache, it is not supported to modify the list of the handlers after the first call to dump/load. Name mangling Name mangling is supported in datatypes with metadata (dataclass, attrs) by having a 'name' key in the metadata. @attr.s class Example: attribute = attr.ib(type=int, metadata={'name': 'att.rib.ute:name'} @dataclass class Example(): attribute: str = field(metadata={'name': 'att.rib.ute:name'}) The dictionary key for 'attribute' will be 'att.rib.ute:name'. This is very useful for keys that use invalid or reserved characters that can't be used in variable names. Another common application is to convert camelCase into not_camel_case. It is implemented this way to avoid doing automatic name translations, that might introduce surprises. To use a metadata key different than 'name', set the mangle_key parameter to the loader/dumper. Functions load Quick function call to load data into a type. It is useful to avoid creating the Loader object, in case only the default parameters are used. For repeated calls this function will be slower than re-using a loader object. dump Quick function to dump a data structure into something that is compatible with json or other programs and languages. It is useful to avoid creating the Dumper object, in case only the default parameters are used.","title":"typedload"},{"location":"typedload_docgen.html#typedload","text":"This library loads Python data structures into typed data structures, enforcing a schema. The main purpose is to load things that come from json, bson or similar into NamedTuple or Dataclass. For example this Json: { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this: class User(NamedTuple): username: str shell: str = 'bash' sessions: List[str] = [] class Logins(NamedTuple): users: List[User] And can then be loaded with typedload.load(data, Logins)","title":"typedload"},{"location":"typedload_docgen.html#simple-api","text":"typedload.load() and typedload.dump() are functions to quickly load and dump data using the default objects. They create a new loader/dumper object with default parameters, and discard it after.","title":"Simple API"},{"location":"typedload_docgen.html#classes","text":"The loader and dumper classes expose a number of attributes that can be customised to tweak their behaviour.","title":"Classes"},{"location":"typedload_docgen.html#supported-datatypes","text":"There is support for: * Basic python types (int, str, bool, float, NoneType) * NamedTuple * Enum * Optional[SomeType] * List[SomeType] * Dict[TypeA, TypeB] * Tuple[TypeA, TypeB, TypeC] * Tuple[SomeType, ...] * Set[SomeType] * Union[TypeA, TypeB] * ForwardRef * Literal * Dataclass * attrs * TypedDict * datetime * Path * IPv4Address, IPv6Address","title":"Supported datatypes"},{"location":"typedload_docgen.html#handlers","text":"To work with other datatypes, handlers can be used. The handlers' list items are tuples for two functions. The signatures are different for loader or dumper. The first function returns a boolean, and if the value is true, the object will call the second function and return its result. Basically a loader and a dumper class have no functionality (but come with a default list of handlers). So, to add support for a new type, it is sufficient to write a function that outputs the desired value, and a function that decides when to call that. The index() function returns the position of handlers in the list, so that it is possible to remove them or add new handlers before or after a given handler. The pointer to the loader or dumper object is passed, so that the attributes in use for that particular object are available. For example, if we want to add a special loader that when loading the int 42 into a string returns 'quarantadue', we can do this: from typedload.dataloader import Loader l = Loader() l.handlers.insert( l.index(str), # This will place this entry before the string handler ( lambda x: x == str, lambda loader, value, type_: str(value) if value != 42 else 'quarantadue' ) ) Then this will happen: In [15]: l.load(12, str) Out[15]: '12' In [16]: l.load(42, str) Out[16]: 'quarantadue' This can of course be used also for use cases that make sense. The handlers must generate exceptions from the typedload.exceptions module. Due to internal cache, it is not supported to modify the list of the handlers after the first call to dump/load.","title":"Handlers"},{"location":"typedload_docgen.html#name-mangling","text":"Name mangling is supported in datatypes with metadata (dataclass, attrs) by having a 'name' key in the metadata. @attr.s class Example: attribute = attr.ib(type=int, metadata={'name': 'att.rib.ute:name'} @dataclass class Example(): attribute: str = field(metadata={'name': 'att.rib.ute:name'}) The dictionary key for 'attribute' will be 'att.rib.ute:name'. This is very useful for keys that use invalid or reserved characters that can't be used in variable names. Another common application is to convert camelCase into not_camel_case. It is implemented this way to avoid doing automatic name translations, that might introduce surprises. To use a metadata key different than 'name', set the mangle_key parameter to the loader/dumper.","title":"Name mangling"},{"location":"typedload_docgen.html#functions","text":"","title":"Functions"},{"location":"typedload_docgen.html#load","text":"Quick function call to load data into a type. It is useful to avoid creating the Loader object, in case only the default parameters are used. For repeated calls this function will be slower than re-using a loader object.","title":"load"},{"location":"typedload_docgen.html#dump","text":"Quick function to dump a data structure into something that is compatible with json or other programs and languages. It is useful to avoid creating the Dumper object, in case only the default parameters are used.","title":"dump"},{"location":"version_numbers.html","text":"Version numbers Breaking API changes happen when the first number increases. So far they have been minimal. The second number being bumped means bugs were fixed or new features introduced, but the API remained compatible. Dropping support for EOL python versions is not considered breaking API. Changes that trigger failures in buggy code are acceptable See here . I am not Linus Torvalds and I don't have to follow his rules.","title":"Versioning scheme"},{"location":"version_numbers.html#version-numbers","text":"Breaking API changes happen when the first number increases. So far they have been minimal. The second number being bumped means bugs were fixed or new features introduced, but the API remained compatible. Dropping support for EOL python versions is not considered breaking API. Changes that trigger failures in buggy code are acceptable See here . I am not Linus Torvalds and I don't have to follow his rules.","title":"Version numbers"}]}