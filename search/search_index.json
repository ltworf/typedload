{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typedload Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. Note that it is released with a GPL license and it cannot be used inside non GPL software. Example For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data) Supported types Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address Using Mypy # This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format. Install pip install typedload apt install python3-typedload Latest and greatest .deb file is in https://github.com/ltworf/typedload/releases Documentation See the file example.py to see a basic usecase for this module. The tests are harder to read but provide more in depth examples of the capabilities of this module. Used by As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Home"},{"location":"#typedload","text":"Load and dump json-like data into typed data structures in Python3, enforcing a schema on the data. This module provides an API to load dictionaries and lists (usually loaded from json) into Python's NamedTuples, dataclass, sets, enums, and various other typed data structures; respecting all the type-hints and performing type checks or casts when needed. It can also dump from typed data structures to json-like dictionaries and lists. It is very useful for projects that use Mypy and deal with untyped data like json, because it guarantees that the data will follow the specified schema. Note that it is released with a GPL license and it cannot be used inside non GPL software.","title":"typedload"},{"location":"#example","text":"For example this dictionary, loaded from a json: data = { 'users': [ { 'username': 'salvo', 'shell': 'bash', 'sessions': ['pts/4', 'tty7', 'pts/6'] }, { 'username': 'lop' } ], } Can be treated more easily if loaded into this type: @dataclasses.dataclass class User: username: str shell: str = 'bash' sessions: List[str] = dataclasses.field(default_factory=list) class Logins(NamedTuple): users: List[User] And the data can be loaded into the structure with this: t_data = typedload.load(data, Logins) And then converted back: data = typedload.dump(t_data)","title":"Example"},{"location":"#supported-types","text":"Since this is not magic, not all types are supported. The following things are supported: Basic python types (int, str, bool, float, NoneType) NamedTuple Enum Optional[SomeType] List[SomeType] Dict[TypeA, TypeB] Tuple[TypeA, TypeB, TypeC] and Tuple[SomeType, ...] Set[SomeType] Union[TypeA, TypeB] dataclass (requires Python 3.7) attr.s ForwardRef (Refer to the type in its own definition) Literal (requires Python 3.8) TypedDict (requires Python 3.8) datetime.date, datetime.time, datetime.datetime Path IPv4Address, IPv6Address","title":"Supported types"},{"location":"#using-mypy","text":"# This is treated as Any, no checks done. data = json.load(f) # This is treated as Dict[str, int] # but there will be runtime errors if the data does not # match the expected format data = json.load(f) # type: Dict[str, int] # This is treated as Dict[str, int] and an exception is # raised if the actual data is not Dict[str, int] data = typedload.load(json.load(f), Dict[str, int]) So when using Mypy, it makes sense to make sure that the type is correct, rather than hoping the data will respect the format.","title":"Using Mypy"},{"location":"#install","text":"pip install typedload apt install python3-typedload Latest and greatest .deb file is in https://github.com/ltworf/typedload/releases","title":"Install"},{"location":"#documentation","text":"See the file example.py to see a basic usecase for this module. The tests are harder to read but provide more in depth examples of the capabilities of this module.","title":"Documentation"},{"location":"#used-by","text":"As dependency, typedload is used by those entities. Feel free to add to the list. Several universities around the world United States Air Force Exxonmobil","title":"Used by"},{"location":"comparisons/","text":"Comparisons In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are: It works with existing codebase Most libraries require your classes to extend or use decorators from the library itself. Instead, typedload works fine with the type annotations from the typing module and will work without requiring changes to the datatypes. It is easy to extend Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases. pydantic Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Does not handle Union, Set, Path dataclasses-json Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"Comparisons"},{"location":"comparisons/#comparisons","text":"In this section we compare typedload to other similar libraries. In general, the advantages of typedload over competing libraries are:","title":"Comparisons"},{"location":"comparisons/#it-works-with-existing-codebase","text":"Most libraries require your classes to extend or use decorators from the library itself. Instead, typedload works fine with the type annotations from the typing module and will work without requiring changes to the datatypes.","title":"It works with existing codebase"},{"location":"comparisons/#it-is-easy-to-extend","text":"Since there can be situations that are highly domain specific, typedload allows to extend its functionality to support more types or replace the existing code to handle special cases.","title":"It is easy to extend"},{"location":"comparisons/#pydantic","text":"Found here Slower than typedload for complex data (but faster for simple non-nested data) Requires all the classes to derive from a superclass Does not work with mypy: Abuses python typing annotation to mean something different, breaking linters Uses float=None without using Optional in its own documentation . Does not handle Union, Set, Path","title":"pydantic"},{"location":"comparisons/#dataclasses-json","text":"Found here 20x slower than typedload Does not check types Requires to decorate all the classes It is not extensible Doesn't support Union (and other types) Has dependencies (marshmallow, marshmallow-enum, typing-inspect) Very complicated way for doing lists","title":"dataclasses-json"},{"location":"examples/","text":"Examples Objects TODO Optional values TODO Unions Disable cast TODO List or single object Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_point # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points typedload.load(data1, Data).data_points typedload.load(data2, Data).data_points Objects TODO Object type in value Let's assume that our json objects contain a type field that names the object itself. Slack sends events in this way for example. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]]) Name mangling Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) When dumping back the data typedload.dump(character) the names will be converted back to camel case. Multiple name mangling schemes If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) typedload.dump(character, mangle_key='alt_name') Custom handlers TODO Exceptions TODO","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#objects","text":"TODO","title":"Objects"},{"location":"examples/#optional-values","text":"TODO","title":"Optional values"},{"location":"examples/#unions","text":"","title":"Unions"},{"location":"examples/#disable-cast","text":"TODO","title":"Disable cast"},{"location":"examples/#list-or-single-object","text":"Some terribly evil programmers use json in this way: A list in case they have multiple values A single object in case they have one value Nothing at all in case they have zero values Let's see how typedload can help us survive the situation without having to handle all the cases every time. import typedload from typing import NamedTuple, Union, List import dataclasses # Multiple data points, a list is used data0 = { \"data_points\": [{\"x\": 1.4, \"y\": 4.1}, {\"x\": 5.2, \"y\": 6.13}] } # A single data point. Instead of a list of 1 element, the element is passed directly data1 = { \"data_points\": {\"x\": 1.4, \"y\": 4.1} } # No data points. Instead of an empty list, the object is empty data2 = {} # Now we make our objects class Point(NamedTuple): x: float y: float @dataclasses.dataclass class Data: # We make an hidden field to load the data_points field from the json # If the value is absent it will default to an empty list # The hidden field can either be a List[Point] or directly a Point object _data_points: Union[Point, List[Point]] = dataclasses.field(default_factory=list, metadata={'name': 'data_points'}) @property def data_points(self) -> List[Point]: # We make a property called data_points, that always returns a list if not isinstance(self._data_points, list): return [self._data_points] return self._data_point # Now we can load our data, and they will all be lists of Point typedload.load(data0, Data).data_points typedload.load(data1, Data).data_points typedload.load(data2, Data).data_points","title":"List or single object"},{"location":"examples/#objects_1","text":"TODO","title":"Objects"},{"location":"examples/#object-type-in-value","text":"Let's assume that our json objects contain a type field that names the object itself. Slack sends events in this way for example. import typedload from typing import List, Literal, Union, NamedTuple events = [ { \"type\": \"message\", \"text\": \"hello\" }, { \"type\": \"user-joined\", \"username\": \"giuf\u00e0\" } ] # We have events that can be of many types class Message(NamedTuple): type: Literal['message'] text: str class UserJoined(NamedTuple): type: Literal['user-joined'] username: str # Now to load our event list typedload.load(events, List[Union[Message, UserJoined]])","title":"Object type in value"},{"location":"examples/#name-mangling","text":"Name mangling is primarily used to deal with camel-case in codebases that use snake_case. It is supported using dataclass and attrs , which provide metadata for the fields. Let's assume that our original data uses camel case. Since we are not maniacs, we want the fields in python to use snake_case, we do the following: from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName'}) last_name: str = field(metadata={'name': 'lastName'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) When dumping back the data typedload.dump(character) the names will be converted back to camel case.","title":"Name mangling"},{"location":"examples/#multiple-name-mangling-schemes","text":"If we want to load from a source and dump to another source that uses a different convention, we can use mangle_key from dataclasses import dataclass, field import typedload @dataclass class Character: first_name: str = field(metadata={'name': 'firstName', 'alt_name': 'first-name'}) last_name: str = field(metadata={'name': 'lastName', 'alt_name': 'last-name'}) data = {\"firstName\": \"Paolino\", \"lastName\": \"Paperino\"} character = typedload.load(data, Character) typedload.dump(character, mangle_key='alt_name')","title":"Multiple name mangling schemes"},{"location":"examples/#custom-handlers","text":"TODO","title":"Custom handlers"},{"location":"examples/#exceptions","text":"TODO","title":"Exceptions"},{"location":"origin_story/","text":"typedload's origin story","title":"Origin story"},{"location":"origin_story/#typedloads-origin-story","text":"","title":"typedload's origin story"}]}